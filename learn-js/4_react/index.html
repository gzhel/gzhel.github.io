<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../styles.css">
    <title>Тематические разделы</title>
</head>
<body>
<div class="learn-page__layout checklist" style="padding-bottom: 50px;">
    <h1><a href="../index.html" style="color: aliceblue;">Back to main page</a></h1>
    <section class="learn-page__layout--study-block">
        <h3>Обозначения (субъективно):</h3>
        <div><span class="blue">Синий</span>: актуально, не очевидно, secret knowledge</div>
        <div><span class="green">Зеленый</span>: актуально, стоит изучать внимательно</div>
        <div><span style="color: red">Красный</span>: допустимо, в 99% случаев не используется</div>
        <div><span class="violet">Фиолетовый</span>: актуально, расширенный полезный материал</div>
        <div style="margin-bottom: 6px;"><span class="orange">Оранжевый</span>: пока не понятно, в процессе изучения материала</div>
        <div>
            <span><button id="show_reds">Показать "красные" пункты</button></span>
            <span><button id="hide_reds">Скрыть "красные" пункты</button></span>
            <span><button id="hide_for_what">Скрыть разделы "Зачем?"</button></span>
            <span><button id="hide_practise">Скрыть разделы "Практика"</button></span>
        </div>
    </section>
    <section class="learn-page__layout--study-block">
        <div class="text" style="background-color: white;">
            <b>1) Основные понятия</b><hr>
            <div>
                <input type="checkbox" name="1_1" id="1_1">
                <label for="1_1">1.1 Знакомство с JSX</label>
                <p class="for-what">Зачем мне нужен JSX? Делает работу с разметкой страницы наглядее, если бы не он, то нужно было бы писать React.createElement(...)</p>
                <ul>
                    <li>В JSX мы пишем код похожий на HTML, если бы не он, то нужно было бы писать React.createElement(type, props, children)</li>
                    <li>Внутри тегов JSX можно добавить любой код (if, строки, числа, функции итд), делается это через {fieldName}</li>
                    <li>JSX можно использовать для маппинга, вместе с if (и a ? b : c), и JSX можно присвоить переменной (т.к. JSX становится JS объектом)</li>
                    <li>Атрибуты (props) в JSX пишутся через camelCase, строки нужно присваивать через ="", а не ={""}, переменные через ={varName}</li>
                    <li>Все данные для отображения внутри JSX {} преобразуются в строки, что защищает от выполнения левых скриптов</li>
                    <li>Стоит понимать что JSX это простые теги вроде div, "компонент" же это функция, которая, как правило использует JSX</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_2" id="1_2">
                <label for="1_2">1.2 Рендеринг элемента в DOM</label>
                <p class="for-what">Зачем мне это нужно? Если этого не знать, то можно словить множество сайд-эффектов, это то, зачем нужна мемоизация</p>
                <ul>
                    <li>React-элемент это не React-компонент, элемент это кусочек с JSX, компонент это функция, состоящая из этих элементов</li>
                    <li>В каждом React-приложении есть html файлик и в нём где-то есть div с id "root" или "mountNode", и на самом деле в приложении их может сколько угодно</li>
                    <li>Для того чтобы зарендерить какой-то "элемент" или "компонент" используют ReactDOM.render(element, document.getElementById('mountNode'))</li>
                    <li>Элементы иммутабельны, то есть как некое "фото" или "кадр", при смене состояния "фото1" сравнивается с "фото2" и меняет только то, что поменялось</li>
                    <li>Порядок изменения состояния следующий: есть "фото1" оно отрисовано в DOM, состояние поменялось, появилось "фото2", сравнили их, отрисовали изменения в DOM</li>
                    <li>Стоит понять самое главное: на каждое изменение создаётся абсолютно новый компонент, но в DOM изменится лишь разница между компонент1 и компонент2</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_3" id="1_3">
                <label for="1_3">1.3 Компоненты и пропсы</label>
                <p class="for-what">Зачем мне нужны "компоненты"? Компоненты позволяют разбить приложение на мелкие части, модули, с которыми легко работать по отдельности</p>
                <ul>
                    <li>React-компонент похож на обычную JS-функцию, он может принимать некие props, которые являются данными из вне, и возвращает JSX с тем, что мы хотим видеть</li>
                    <li>Классовые компоненты устарели, сейчас пишут на функциональных, которые гораздо более компактные, и используют React-хуки, вместо методов класса</li>
                    <li>Аналогично React-элементам, компоненты можно записать в переменную, и использовать например как a ? B : C, отрисовав нужный по условию компонент</li>
                    <li>Внутри компонента можно использовать компоненты, причём можно использовать одинаковые компонеты с разными props, а также один компонент несколько раз подряд</li>
                    <li>Декомпозиция это важный принцип в React, поэтому если нужно разбить компонент на более мелкие компоненты, то это стоит сделать</li>
                    <li>Props это данные для компонента из вне (строки, функции итд), не следует "мутировать" пропсы внутри компонента, компоненты должны быть как чистые функции</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_4" id="1_4">
                <label for="1_4">1.4 Состояние и жизненный цикл</label>
                <p class="for-what">Зачем мне это нужно? Приложение не статическое, поэтому у него должно быть состояние, жизненный цикл это эффекты, за которые можно цепляться</p>
                <ul>
                    <li>Как было раньше №1? В классовом компоненте состояние зависело от this.state в constructor и this.setState(), доступ к props осуществлялся через this.props</li>
                    <li>Как было раньше №2? Были методы жизненного цикла: componentDidMount/Update (на монтирование/на изм. сост.), componentWillUnmount (на размонтирование)</li>
                    <li>Как было раньше №3? Чтобы использовать методы класса, нужно было из забиндить в constructor через this.methodName = this.methodName.bind(this)</li>
                    <li>Как стало теперь №1, 2, 3? Используется хук useState, this не нужен, хук useEffect вместо методов ЖЦ, биндить внутренние функции не нужно</li>
                    <li>Порядок выполнения: передаём "компонент" в ReactDOM.render(), компонент рендерится, как только компонент в DOM, срабатывает componentDidMount</li>
                    <li>Изменять состояние напрямую нельзя, только через setState, если принебречь этим, состояние изменится, но ререндер не будет совершён (!!! перепроверить !!!)</li>
                    <li>Можно представить содержимое для state как объект со всеми нужными полями, тогда состояние будет меняться следующим образом: setState({...state, field: 1})</li>
                    <li>Не стоит полагаться на state внутри setState, вместо этого, нужно добавить функцию в setState и там достать prevState: setState((prev) => {...prev, field: 1})</li>
                    <li>UPD: важное замечание, мы могли делать большие объекты в классовом state, в новом state получим ошибки, поэтому такая записаь актуальна: setState(pr => pr + 1)</li>
                    <li>В React "однонаправленный" и "нисходящий" поток данных, т.е. props можно прокинуть только дочерним компонентам, это называется "props drilling"</li>
                    <li>Последний момент, о котором стоит упомянуть в этом разделе: в JSX у каждого экземпляра компонента своё состояние, независимое от других экземпляров</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_5" id="1_5">
                <label for="1_5">1.5 Обработка событий</label>
                <p class="for-what">Зачем мне это нужно? В JSX пособ обработки событий сильно отличается от того, что есть в JavaScript, события диктуют динамику на странице</p>
                <ul>
                    <li>В React функции пишут через camelCase, также в JSX передаём функцию, а не строку: onclick="doIt()" -> onClick={doIt} (JS и JSX)</li>
                    <li>Важный момент, нельзя передавать функцию как onClick={doIt()}, так она вызовется сразу, но можно сделать ={doIt} или ={() => doIt()} это равносильная запись</li>
                    <li>В JS на form submit обновлялась страница, чтобы обновления не было в React, нужно на функцию которая идёт на submit вешать e.preventDefault()</li>
                    <li>В JS чтобы добавить событие на дейстие, был нужен addEventListener, в React он не нужен, и можно сразу добавлять функцию внурть действия (onClick итд)</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_6" id="1_6">
                <label for="1_6">1.6 Условный рендеринг (отображение JSX по условию)</label>
                <p class="for-what">Зачем мне это нужно? Используется повседневно, когда нужно прятать или показывать элемент в зависимости от состояния</p>
                <ul>
                    <li>В зависимости от условия (флажка, любого другого объекта) можно отрисовать тот или иной компонент, это делается либо через if, либо через тернарный оператор</li>
                    <li>Стоит понимать, что "компонент" всегда возвращает JSX, и точно так же как в обычной функции, если сработал return, то до следующего return код не дойдёт</li>
                    <li>Как правило if (isOne) {return Component1} делается перед "основным" return, если используем тернарный оператор, он используется внутри {} в JSX {isA ? A : B}</li>
                    <li>Если нужно предотвратить рендеринг компонента, нужно добавить if (isA) return null, либо return isA ? null : Component, при этом методы ЖЦ всё равно сработают</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_7" id="1_7">
                <label for="1_7">1.7 Списки (массивы) и ключи</label>
                <p class="for-what">Зачем мне это нужно? Когда нужно показать несколько компонентов с данными, используют Array.map(), ключи это идентификаторы для React</p>
                <ul>
                    <li>Если нужно отрисовать несколько одинаковых JSX элементов или компонентов, наполненных различными данными, используют Array.map(): Bees.map(bee => Bee with props)</li>
                    <li>У каждого элемента или компонента после .map должен быть уникальный props "key" (строка), они нужны чтобы React мог сопоставлять элементы при изменении массива</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_8" id="1_8">
                <label for="1_8">1.8 Формы</label>
                <p class="for-what">Зачем? ??? Для хранения данных, отправки данных на бекенд</p>
                <ul>
                    <li></li>
                    <li class="blue">Если в HTML формы сами хранят свой state, то в React обычно используют state и setState</li>
                    <li class="green">Чтобы сделать элемент формы "управляемым", он должен иметь поля вроде onChange или onSubmit, и мы должны их обработать</li>
                    <li class="blue">На примере инпута, каждый введенный символ вызывает функцию onChange, а значит ререндерит компонент инпута</li>
                    <li class="green">В <\select> есть <\option> с полем value, который определяется через value элемента <\select></li>
                    <li class="blue">input file позволяет загрузить файл с устройства на сервер, его значение доступно только для чтения (неуправляемый)</li>
                    <li class="green">В случае, если у нас несколько инпутов, им нужен name, чтобы была записать типо setState({[evt.target.name]: value})</li>
                    <li class="blue">setState делает слияние части с ключом A в объект state, при этом в state могут быть и другие значения</li>
                    <li class="violet">Управляемый компонент это тот, условно value и onChange которого зависят от [state, setState] = useState()</li>
                    <li class="violet">Двухстороннее связывание это связывание стейта React со стейтом элемента (например инпута) в DOM</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_9" id="1_9">
                <label for="1_9">1.9 Подъём состояния</label>
                <p class="for-what">Зачем? Состояние дочерних компонентов могут понадобиться внутри родительских например чтобы их сравнить</p>
                <ul>
                    <li class="blue">Подъём состояния это бред, такие вещи стоит делать через Redux или Context (если мы не хотим писать много кода)</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_10" id="1_10">
                <label for="1_10">1.10 Композиция против наследования</label>
                <p class="for-what">Зачем? Теоретическое знание, просто чтобы понять что есть что и не писать плохой код</p>
                <ul>
                    <li class="blue">Композиция - "частный" компонент рендерит "общий" компонент и настраивает его с помощью пропсов WelcomeDark -> Welcome</li>
                    <li class="green">Если мы пока не знаем что за дочерний компонент, можно использовать {children}, который есть у всех компонентов</li>
                    <li class="blue">Наследование - лучше не знать и не использовать, в React это просто ненужное усложенеие жизни себе и другим</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_11" id="1_11">
                <label for="1_11">1.11 Философия React</label>
                <p class="for-what">Зачем? React это приложение по кубикам лего, отдельный кубик - отдельная микрожизнь внутри него, он самостоятелен</p>
                <ul>
                    <li class="green">Шаг 1: разбить макет на составляющие будущего интерфейса, дать имена этим компонентам, 1 компонент - 1 задача</li>
                    <li class="green">Шаг 2: создать статическое приложение на основе этих компонентов, просто статика, данные можно через пропсы (не state)</li>
                    <li class="green">Шаг 3: делаем минимальную динамику фиче, при помощи state</li>
                    <li class="green">Шаг 4: определяемся, где должно находиться состояние, это может быть родитель, но я считаю что самостоятельные модули лучше</li>
                    <li class="green">Шаг 5: добавление обратного потока данных, которое не актуально, если мы используем самостоятельные модули из пункта выше</li>
                    <li class="blue">По факту: разбить макет на компоненты, сделать статику, сделать FLUX подход, шаги выше это очень усложнённый вариант</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_12" id="1_12">
                <label for="1_12">1.12 Дополнительно</label>
                <p class="for-what">Зачем? ...</p>
                <ul>
                    <li class="violet">MPA (multi): куча файлов HTML, каждый сам по себе обладает какой-то логикой, каждый файл это отдельная страница</li>
                    <li class="violet">SPA (single): есть один mountNode, всё остальное это дочерние элементы для mountNode компонента</li>
                    <li class="violet">В React есть "дерево React элементов" (Virtual DOM), когда в нём что-то меняется, React строит новое дерево элементов с новыми значениями, и сравнивает его с предыдущим (а уже после добавляет в DOM), это называется "Согласование" (Reconciliation)</li>
                    <li class="violet">Файлы содержащие JSX создаются с расширением .jsx, .tsx, чтобы создать FC в WebStorm пишем rsc и жмём Tab</li>
                    <li class="violet">Файл называется так же как и компонент в нём, компонент обязательно должен возвращать какой-то JSX, компонент нужно экспортить</li>
                    <li class="violet">У классового (устаревшего) компонента в constructor есть 3 сущности: super(props), this.state = {...} и бинды для функций</li>
                    <li class="violet">Хуки: useState/Effect/Ref/Memo/Callback/Context это функции, их можно использовать в FC или внутри кастомных хуков, только на верхнем уровне вложенности, не можем вкладывать в {}, функции итд</li>
                    <li class="violet">Браузер добавляет свои стили, их нужно обнулить в файле стилей через * {margin: 0; padding: 0; box-sizing: border-box;}</li>
                    <li class="violet">Модули CSS: ComponentName.module.css, классы через camelCase, импорт как s from 'xxx.module.css', className={s.styleName}</li>
                    <li class="violet">Пропс под названием {children} обозначает дочерний узел в компоненте реакта, то есть Comp1 CompChild Comp1</li>
                    <li class="violet">Если пропсов много, их можно передать как ({...props}), а также развернуть внутри JSX узла как {...props}</li>
                    <li class="violet">Чтобы получить данные из неуправляемого инпута нужен useRef, он даст доступ к DOM-элементу и у него можно будет забрать value</li>
                    <li class="violet">Чтобы передать Ref в дочерний компонент, его нужно обернуть в forwardRef(), тогда вторым параметром у компонента будет ref</li>
                    <li class="violet">В setState если state это массив, то если мы не хотим затирать предыдущий state, пишут так setState([...state, newState])</li>
                    <li class="violet">Если нужно, изменить поле объекта, но оставить в порядке другие поля запись следующая {...fields, field5: 'something'}</li>
                    <li class="violet">Чтобы передать данные от ребёнка к родителю, нужно из родителя передать колбэк функцию в дочерний компонент и в дочернем передать в этот колбэк изменённые данные</li>
                    <li class="violet">Чтобы создать сортировку нужен селект, который содержить названия полей, по которым будем сортировать, используем фунцию a.localeCompare(b)</li>
                    <li class="violet">При изменению инпута на каждый нажатый символ меняется state, тут помогает useMemo(callback, deps) - callback должен возвращать результат каких-то вычислений</li>
                    <li class="violet">Как работает useMemo: производит вычисление 1 раз, запоминает результат вычисления и кэширует, на каждую перерисовку компонента вычисление не будет производиться вновь, но каждый раз когда меняется deps, функция вновь пересчитывает и кэширует уже новый результат</li>
                    <li class="violet">Для анимаций у React есть библиотека "react-transition-group", этот компонент является обёрткой, элементы обёрнуты в CSSTransition, нужно копировать стили либы в CSSTransition</li>
                    <li class="violet">В кастомные хуки можно добавлять логику которая была на верхнем уровне Компонента и имела на верхнем уровне обычные хуки, нужны для декомпозиции и в целом всё</li>
                    <li class="violet">Для работы с сервером обычно используют axios, для этого достаточно axios.get(), axios.post(), то что нам нужно находится в response.data</li>
                    <li class="violet">Жизненный цикл компонента состоит из трёх стадий: mount, update, unmount, и всех их можно обработать в useEffect, при этом useEffect можно использовать несколько раз в одном компоненте</li>
                    <li class="violet">Все API стоит выносить в отдельные файлы типа xxx.service, который будет является классом, а запрашиваемые данные будут static async методами</li>
                    <li class="violet">Query параметры указываются полсе знака "?", разделяются знаком "&", например: /posts?_limit=5&_page=2</li>
                    <li class="violet">Есть следующие виды Query-параметров: _limit=N (кол-во JSON объектов), _page=N (номер страницы), x-total-count в Network запросе это общее кол-во объектов, которое может вернуть сервер</li>
                    <li class="violet">В axios после URL вторым параметром можно указать params, где как раз можно вписать _limit и _page, там же можно достать из response.headers['x-total-count'] и поделить его на limit, тогда мы узнаем, сколько страниц должно быть в пагинации (не забыть обернуть в Math.ceil)</li>
                    <li class="violet">Изменение состояния это асинхронный процесс !!! то есть если мы в рамках одного метода changePage(page) {setPage(page); fetchPosts();} сменили page через setPage, а fetchPosts() использует этот page, то он получит старое состояние page</li>
                    <li class="violet">Как это исправить? Сделать эффект, т.е. добавить useEffect, который делает fetchPosts() если меняется [page] в deps</li>
                    <li class="violet">Как исправить без useEffect? Сделать changePage(page) {setPage(page); fetchPosts(limit, page);} и внутри fetchPosts в асинхронную функцию fetching передать ...args и в callback передать ...args, т.к. кол-во аргументов неизвестно</li>
                    <li class="violet">Переиспользуемость это очень важно, поэтому стоит декомпозировать код</li>
                    <li class="violet">Для навигации по страницам в React исползуют react-router-dom (не путать с react-router), нужно App обернуть в BrowserRouter, для навигации используется Route с path по которому страница должна отрисовываться</li>
                    <li class="violet">На этом же этапе можно добавить какой-то Layout, или Navbar, которые будут являться обёрткой для роутов</li>
                    <li class="violet">Для переключения страниц нужно использовать Link вместо тега "a", вместо href будет to, тогда переходы между страницами будут без перезагрузки страницы</li>
                    <li class="violet">Route компоненты нужно обернуть в Switch, если ни один из маршрутов не сработает, то сработает Redirect на страницу с ошибкой</li>
                    <li class="violet">Редиректы можно делать не только через Link и Redirect, но и ещё через history.push('/') из useHistory() из 'react-router-dom' НЕ ИЗ 'react'</li>
                    <li class="violet">Хук useParams из 'react-router-dom' возвращает объект с параметрами из URL (id и так далее), подходит для получения данных с сервера по ID</li>
                    <li class="violet">Приватные и публичные маршруты: можно создать export const privateRoutes, содержащий объекты типа {path: ..., component: ..., exact: ...}, роуты будут добавляться как router.map(route => Route with route props)</li>
                    <li class="violet">Для публичных роутов (как правило это страница Логина) нужно создать другой массив, а в компоненте Router достать какой-то флажок типа "isAuth" и отрисовывать privateRoutes только если этот флажок true</li>
                    <li class="violet">Для доступа к "глобальным переменным" используют либо shared store, либо useContext, глобальные данные передаются в Context, из контекста куда угодно</li>
                    <li class="violet">Но тут есть проблема: при обновлении страницы все стейты сбрасываются, поэтому их нужно где-то хранить, например в localStorage, если ключ есть в LS, то ставим isAuth true</li>
                    <li class="violet">В случае когда мы авторизируемся, не нужно показывать Routes, поэтому если так, то просто возвращает какой-то прелоадер</li>
                    <li class="violet">Чтобы сделать бесконечную ленту нужно помещать данные в конец тех, что уже есть, т.е. setData([...oldData, ...newData]), подобный функционал помогает сделать Observer API</li>
                    <li class="violet">Для такой загрузки в самом низу страницы можно создать невидимый блок, доходя до которого будет происходить подгрузка данных, для получения этого элемента используют useRef(), далее используем код из Observer API</li>
                </ul>
            </div>
            <div>
                <p class="helpful" style="padding: 10px;">
                    <span>Практика: </span><a href="https://jsfiddle.net/gzhel/zpgkfvLm/143/" target="_blank">DOM, BOM, высота, скроллы</a>
                </p>
            </div>
        </div>
    </section>
</div>
<script>
    const showReds = document.querySelector("#show_reds");
    const hideReds = document.querySelector("#hide_reds");
    const reds = document.querySelectorAll('.hidden');
    showReds.addEventListener('click', () => reds.forEach(red => red.tagName === "LI"? red.style.display = 'list-item' : red.style.display = 'block'));
    hideReds.addEventListener('click', () => reds.forEach(red => red.style.display = 'none'));

    const hideForWhat = document.querySelector("#hide_for_what");
    const forWhat = document.querySelectorAll(".for-what");
    hideForWhat.addEventListener('click', () => forWhat.forEach(el => el.style.display = 'none'));

    const hidePractise = document.querySelector("#hide_practise");
    const practise = document.querySelectorAll(".helpful");
    hidePractise.addEventListener('click', () => practise.forEach(el => el.style.display = 'none'));
</script>
</body>
</html>
