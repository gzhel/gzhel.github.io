<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../styles.css">
    <title>Тематические разделы</title>
</head>
<body>
<div class="learn-page__layout checklist" style="padding-bottom: 50px;">
    <h1><a href="../index.html" style="color: aliceblue;">Back to main page</a></h1>
    <section class="learn-page__layout--study-block">
        <h3>Обозначения (субъективно):</h3>
        <div><span class="blue">Синий</span>: актуально, не очевидно, secret knowledge</div>
        <div><span class="green">Зеленый</span>: актуально, стоит изучать внимательно</div>
        <div><span style="color: red">Красный</span>: допустимо, в 99% случаев не используется</div>
        <div><span class="violet">Фиолетовый</span>: актуально, расширенный полезный материал</div>
        <div style="margin-bottom: 6px;"><span class="orange">Оранжевый</span>: пока не понятно, в процессе изучения материала</div>
        <div>
            <span><button id="show_reds">Показать "красные" пункты</button></span>
            <span><button id="hide_reds">Скрыть "красные" пункты</button></span>
            <span><button id="hide_for_what">Скрыть разделы "Зачем?"</button></span>
            <span><button id="hide_practise">Скрыть разделы "Практика"</button></span>
        </div>
    </section>
    <section class="learn-page__layout--study-block">
        <div class="text" style="background-color: white;">
            <b>1) Основные понятия</b><hr>
            <div>
                <input type="checkbox" name="1_1" id="1_1">
                <label for="1_1">1.1 Знакомство с JSX</label>
                <p class="for-what">Зачем? Делает работу с разметкой страницы наглядее, если бы не он, то нужно было бы писать React.createElement(...)</p>
                <ul>
                    <li class="green">Можно встраивать переменные в JSX, делается это через {fieldName}, в фигурных скобках могут быть любые допустимые JS выражения</li>
                    <li class="green">JSX-фрагмент можно использовать в циклах, вместе с if и для присваивания переменной</li>
                    <li class="blue">В JSX атрибуты пишутся через camelCase, строки нужно присваивать через ="", а не ={""}, переменные через ={varName}</li>
                    <li class="blue">В JSX все данные для отображения преобразуются в строки, что защищает от выполнения левых скриптов</li>
                    <li class="violet">В JSX мы пишем код похожий на HTML, вместо него были бы React.createElement(type, props, children)</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_2" id="1_2">
                <label for="1_2">1.2 Рендеринг элемента в DOM</label>
                <p class="for-what">Зачем? Позволяет понять, что происходит во время изменения состояния компонента</p>
                <ul>
                    <li class="blue">В React-приложении может быть сколько угодно root-элементов, но обычно один, который создаётся через ReactDOM.render(app, root)</li>
                    <li class="blue">При смене состояния, React сравнивает компонент и все его поля с их предудущей версией, и ререндерит только измененные элементы</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_3" id="1_3">
                <label for="1_3">1.3 Компоненты и пропсы</label>
                <p class="for-what">Зачем? Компоненты позволяют разбить приложение на мелкие части, модули, с которыми легко работать по отдельности</p>
                <ul>
                    <li class="green">Сейчас в основном код пишут на функциональных компонентах вида const Welcome = (props) => <\div>{props.name}<\/></li>
                    <li class="blue">React-компоненты могут содержать "пропсы", которые можно использовать внутри компонента: <\Welcome name="Alex" \/></li>
                    <li class="green">React-компоненты могут переиспользоваться с разными пропсами, а также много раз использоваться в другом компоненте</li>
                    <li class="green">Можно дробить React-компоненты на более мелкие, можно хоть прям супер мелко раздробить, но только если это нужно</li>
                    <li class="blue">Правило: React-компоненты должны вести себя как чистые функции в отношении своих пропсов, т.е. не изменять их</li>
                    <li class="violet">Пропсы это данные для компонента из вне, также когда мапим данные, index как ключ использовать не рекомендуется</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_4" id="1_4">
                <label for="1_4">1.4 Состояние и жизненный цикл</label>
                <p class="for-what">Зачем? Приложение не статическое, поэтому у него должно быть состояние, жизненный цикл это эффекты, за которые можно цепляться</p>
                <ul>
                    <li class="green">В классовом компоненте со стейтом управлялись через this.state в constructor и this.setState(), в FC через useState()</li>
                    <li class="green">Методы жизненного цикла: componentDidMount/Update (на монтирование/на изм. сост.), componentWillUnmount (на размонтирование)</li>
                    <li class="blue">Правила состояний: не изменять напрямую (только setState), в setState использовать prevState, один setState - одно поле state</li>
                    <li class="green">Состояние компонента локально, но можно делать prop drilling, передавая состояние родителя дочерним компонентам</li>
                    <li class="blue">Правило: React-компоненты должны вести себя как чистые функции в отношении своих пропсов, т.е. не изменять их</li>
                    <li class="violet">Если мы меняем значение let, то React не поймёт изменений и не совершит ререндер изменяемого компонента</li>
                    <li class="violet">const [state, setState] = useState(initialValue), в современном React состояние меняется так setState(newValue)</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_5" id="1_5">
                <label for="1_5">1.5 Обработка событий</label>
                <p class="for-what">Зачем? Теперь тут заправляет JSX, и мы передаём функции-обработчики уже JSX компонентам, а не HTML элементам</p>
                <ul>
                    <li class="green">В JSX собыитя передаются почти так же как в HTML, он они camelCase и передаются как doIt, а не "doIt()"</li>
                    <li class="blue">Чтобы в JSX функции-обработчике отменить поведение по умолчанию, нужно добавить e.preventDefault() в сам обработчик</li>
                    <li class="green">В JSX не нужен addEventListener, можно вешать обработчик прямо на элемент, либо ссылку на обработчик в компоненте</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_6" id="1_6">
                <label for="1_6">1.6 Условный рендеринг (отображение элемента по условию)</label>
                <p class="for-what">Зачем? Используется очень часто, когда нужно прятать или показывать элемент в зависимости от условия</p>
                <ul>
                    <li class="green">В зависимости от условия (флажка, поля из данных итд) можно отрисовать тот или иной компонент</li>
                    <li class="green">Компоненты можно сохранять в переменные по условию, но это также можно сделать и внутри блока {isA ? A : B}</li>
                    <li class="green">Внутри JSX (т.е. компонента вида <\ComponentA/> можно заключить внутрь {} любые данные и условия</li>
                    <li class="blue">Чтобы предотвратить рендеринг (НЕ показать компонент), нужно условие if по которому будет возвращён null</li>
                    <li class="blue">Тем не менее, даже если компонент не отрисует свой return, методы его жизненного цикла сработают</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_7" id="1_7">
                <label for="1_7">1.7 Списки и ключи</label>
                <p class="for-what">Зачем? Когда нужно показать несколько компонентов с данными, используют Array.map(), ключи это идентификаторы для React</p>
                <ul>
                    <li class="green">Если нужно показать несколько одинаковых по HTML элементов или компонентов с разными данными, используют Array.map()</li>
                    <li class="green">У каждого "родительского" элемента в .map должен быть уникальный по значению props под названием key (строковый)</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_8" id="1_8">
                <label for="1_8">1.8 Формы</label>
                <p class="for-what">Зачем? Для хранения данных, отправки данных на бекенд</p>
                <ul>
                    <li class="blue">Если в HTML формы сами хранят свой state, то в React обычно используют state и setState</li>
                    <li class="green">Чтобы сделать элемент формы "управляемым", он должен иметь поля вроде onChange или onSubmit, и мы должны их обработать</li>
                    <li class="blue">На примере инпута, каждый введенный символ вызывает функцию onChange, а значит ререндерит компонент инпута</li>
                    <li class="green">В <\select> есть <\option> с полем value, который определяется через value элемента <\select></li>
                    <li class="blue">input file позволяет загрузить файл с устройства на сервер, его значение доступно только для чтения (неуправляемый)</li>
                    <li class="green">В случае, если у нас несколько инпутов, им нужен name, чтобы была записать типо setState({[evt.target.name]: value})</li>
                    <li class="blue">setState делает слияние части с ключом A в объект state, при этом в state могут быть и другие значения</li>
                    <li class="violet">Управляемый компонент это тот, условно value и onChange которого зависят от [state, setState] = useState()</li>
                    <li class="violet">Двухстороннее связывание это связывание стейта React со стейтом элемента (например инпута) в DOM</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_9" id="1_9">
                <label for="1_9">1.9 Подъём состояния</label>
                <p class="for-what">Зачем? Состояние дочерних компонентов могут понадобиться внутри родительских например чтобы их сравнить</p>
                <ul>
                    <li class="blue">Подъём состояния это бред, такие вещи стоит делать через Redux или Context (если мы не хотим писать много кода)</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_10" id="1_10">
                <label for="1_10">1.10 Композиция против наследования</label>
                <p class="for-what">Зачем? Теоретическое знание, просто чтобы понять что есть что и не писать плохой код</p>
                <ul>
                    <li class="blue">Композиция - "частный" компонент рендерит "общий" компонент и настраивает его с помощью пропсов WelcomeDark -> Welcome</li>
                    <li class="green">Если мы пока не знаем что за дочерний компонент, можно использовать {children}, который есть у всех компонентов</li>
                    <li class="blue">Наследование - лучше не знать и не использовать, в React это просто ненужное усложенеие жизни себе и другим</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_11" id="1_11">
                <label for="1_11">1.11 Философия React</label>
                <p class="for-what">Зачем? React это приложение по кубикам лего, отдельный кубик - отдельная микрожизнь внутри него, он самостоятелен</p>
                <ul>
                    <li class="green">Шаг 1: разбить макет на составляющие будущего интерфейса, дать имена этим компонентам, 1 компонент - 1 задача</li>
                    <li class="green">Шаг 2: создать статическое приложение на основе этих компонентов, просто статика, данные можно через пропсы (не state)</li>
                    <li class="green">Шаг 3: делаем минимальную динамику фиче, при помощи state</li>
                    <li class="green">Шаг 4: определяемся, где должно находиться состояние, это может быть родитель, но я считаю что самостоятельные модули лучше</li>
                    <li class="green">Шаг 5: добавление обратного потока данных, которое не актуально, если мы используем самостоятельные модули из пункта выше</li>
                    <li class="blue">По факту: разбить макет на компоненты, сделать статику, сделать FLUX подход, шаги выше это очень усложнённый вариант</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_12" id="1_12">
                <label for="1_12">1.12 Дополнительно</label>
                <p class="for-what">Зачем? ...</p>
                <ul>
                    <li class="violet">MPA (multi): куча файлов HTML, каждый сам по себе обладает какой-то логикой, каждый файл это отдельная страница</li>
                    <li class="violet">SPA (single): есть один mountNode, всё остальное это дочерние элементы для mountNode компонента</li>
                    <li class="violet">В React есть "дерево React элементов" (Virtual DOM), когда в нём что-то меняется, React строит новое дерево элементов с новыми значениями, и сравнивает его с предыдущим (а уже после добавляет в DOM), это называется "Согласование" (Reconciliation)</li>
                    <li class="violet">Файлы содержащие JSX создаются с расширением .jsx, .tsx, чтобы создать FC в WebStorm пишем rsc и жмём Tab</li>
                    <li class="violet">Файл называется так же как и компонент в нём, компонент обязательно должен возвращать какой-то JSX, компонент нужно экспортить</li>
                    <li class="violet">У классового (устаревшего) компонента в constructor есть 3 сущности: super(props), this.state = {...} и бинды для функций</li>
                    <li class="violet">Хуки: useState/Effect/Ref/Memo/Callback/Context это функции, их можно использовать в FC или внутри кастомных хуков, только на верхнем уровне вложенности, не можем вкладывать в {}, функции итд</li>
                    <li class="violet">Браузер добавляет свои стили, их нужно обнулить в файле стилей через * {margin: 0; padding: 0; box-sizing: border-box;}</li>
                    <li class="violet">Модули CSS: ComponentName.module.css, классы через camelCase, импорт как s from 'xxx.module.css', className={s.styleName}</li>
                    <li class="violet">Пропс под названием {children} обозначает дочерний узел в компоненте реакта, то есть Comp1 CompChild Comp1</li>
                    <li class="violet">Если пропсов много, их можно передать как ({...props}), а также развернуть внутри JSX узла как {...props}</li>
                    <li class="violet">Чтобы получить данные из неуправляемого инпута нужен useRef, он даст доступ к DOM-элементу и у него можно будет забрать value</li>
                    <li class="violet">Чтобы передать Ref в дочерний компонент, его нужно обернуть в forwardRef(), тогда вторым параметром у компонента будет ref</li>
                    <li class="violet">В setState если state это массив, то если мы не хотим затирать предыдущий state, пишут так setState([...state, newState])</li>
                    <li class="violet">Если нужно, изменить поле объекта, но оставить в порядке другие поля запись следующая {...fields, field5: 'something'}</li>
                    <li class="violet">Чтобы передать данные от ребёнка к родителю, нужно из родителя передать колбэк функцию в дочерний компонент и в дочернем передать в этот колбэк изменённые данные</li>
                    <li class="violet">Чтобы создать сортировку нужен селект, который содержить названия полей, по которым будем сортировать, используем фунцию a.localeCompare(b)</li>
                    <li class="violet">При изменению инпута на каждый нажатый символ меняется state, тут помогает useMemo(callback, deps) - callback должен возвращать результат каких-то вычислений</li>
                    <li class="violet">Как работает useMemo: производит вычисление 1 раз, запоминает результат вычисления и кэширует, на каждую перерисовку компонента вычисление не будет производиться вновь, но каждый раз когда меняется deps, функция вновь пересчитывает и кэширует уже новый результат</li>
                    <li class="violet">Для анимаций у React есть библиотека "react-transition-group", этот компонент является обёрткой, элементы обёрнуты в CSSTransition, нужно копировать стили либы в CSSTransition</li>
                    <li class="violet">В кастомные хуки можно добавлять логику которая была на верхнем уровне Компонента и имела на верхнем уровне обычные хуки, нужны для декомпозиции и в целом всё</li>
                    <li class="violet">Для работы с сервером обычно используют axios, для этого достаточно axios.get(), axios.post(), то что нам нужно находится в response.data</li>
                    <li class="violet">Жизненный цикл компонента состоит из трёх стадий: mount, update, unmount, и всех их можно обработать в useEffect, при этом useEffect можно использовать несколько раз в одном компоненте</li>
                    <li class="violet">Все API стоит выносить в отдельные файлы типа xxx.service, который будет является классом, а запрашиваемые данные будут static async методами</li>
                    <li class="violet">Query параметры указываются полсе знака "?", разделяются знаком "&", например: /posts?_limit=5&_page=2</li>
                    <li class="violet">Есть следующие виды Query-параметров: _limit=N (кол-во JSON объектов), _page=N (номер страницы), x-total-count в Network запросе это общее кол-во объектов, которое может вернуть сервер</li>
                    <li class="violet">В axios после URL вторым параметром можно указать params, где как раз можно вписать _limit и _page, там же можно достать из response.headers['x-total-count'] и поделить его на limit, тогда мы узнаем, сколько страниц должно быть в пагинации (не забыть обернуть в Math.ceil)</li>
                    <li class="violet">Изменение состояния это асинхронный процесс !!! то есть если мы в рамках одного метода changePage(page) {setPage(page); fetchPosts();} сменили page через setPage, а fetchPosts() использует этот page, то он получит старое состояние page</li>
                    <li class="violet">Как это исправить? Сделать эффект, т.е. добавить useEffect, который делает fetchPosts() если меняется [page] в deps</li>
                    <li class="violet">Как исправить без useEffect? Сделать changePage(page) {setPage(page); fetchPosts(limit, page);} и внутри fetchPosts в асинхронную функцию fetching передать ...args и в callback передать ...args, т.к. кол-во аргументов неизвестно</li>
                    <li class="violet">Переиспользуемость это очень важно, поэтому стоит декомпозировать код</li>
                    <li class="violet">Для навигации по страницам в React исползуют react-router-dom (не путать с react-router), нужно App обернуть в BrowserRouter, для навигации используется Route с path по которому страница должна отрисовываться</li>
                    <li class="violet">На этом же этапе можно добавить какой-то Layout, или Navbar, которые будут являться обёрткой для роутов</li>
                    <li class="violet">Для переключения страниц нужно использовать Link вместо тега "a", вместо href будет to, тогда переходы между страницами будут без перезагрузки страницы</li>
                    <li class="violet">Route компоненты нужно обернуть в Switch, если ни один из маршрутов не сработает, то сработает Redirect на страницу с ошибкой</li>
                    <li class="violet">Редиректы можно делать не только через Link и Redirect, но и ещё через history.push('/') из useHistory() из 'react-router-dom' НЕ ИЗ 'react'</li>
                    <li class="violet">Хук useParams из 'react-router-dom' возвращает объект с параметрами из URL (id и так далее), подходит для получения данных с сервера по ID</li>
                    <li class="violet">Приватные и публичные маршруты: можно создать export const privateRoutes, содержащий объекты типа {path: ..., component: ..., exact: ...}, роуты будут добавляться как router.map(route => Route with route props)</li>
                    <li class="violet">Для публичных роутов (как правило это страница Логина) нужно создать другой массив, а в компоненте Router достать какой-то флажок типа "isAuth" и отрисовывать privateRoutes только если этот флажок true</li>
                    <li class="violet">Для доступа к "глобальным переменным" используют либо shared store, либо useContext, глобальные данные передаются в Context, из контекста куда угодно</li>
                    <li class="violet">Но тут есть проблема: при обновлении страницы все стейты сбрасываются, поэтому их нужно где-то хранить, например в localStorage, если ключ есть в LS, то ставим isAuth true</li>
                    <li class="violet">В случае когда мы авторизируемся, не нужно показывать Routes, поэтому если так, то просто возвращает какой-то прелоадер</li>
                    <li class="violet">Чтобы сделать бесконечную ленту нужно помещать данные в конец тех, что уже есть, т.е. setData([...oldData, ...newData]), подобный функционал помогает сделать Observer API</li>
                    <li class="violet">Для такой загрузки в самом низу страницы можно создать невидимый блок, доходя до которого будет происходить подгрузка данных, для получения этого элемента используют useRef(), далее используем код из Observer API</li>
                </ul>
            </div>
            <div>
                <p class="helpful" style="padding: 10px;">
                    <span>Практика: </span><a href="https://jsfiddle.net/gzhel/zpgkfvLm/143/" target="_blank">DOM, BOM, высота, скроллы</a>
                </p>
            </div>
        </div>
    </section>
</div>
<script>
    const showReds = document.querySelector("#show_reds");
    const hideReds = document.querySelector("#hide_reds");
    const reds = document.querySelectorAll('.hidden');
    showReds.addEventListener('click', () => reds.forEach(red => red.tagName === "LI"? red.style.display = 'list-item' : red.style.display = 'block'));
    hideReds.addEventListener('click', () => reds.forEach(red => red.style.display = 'none'));

    const hideForWhat = document.querySelector("#hide_for_what");
    const forWhat = document.querySelectorAll(".for-what");
    hideForWhat.addEventListener('click', () => forWhat.forEach(el => el.style.display = 'none'));

    const hidePractise = document.querySelector("#hide_practise");
    const practise = document.querySelectorAll(".helpful");
    hidePractise.addEventListener('click', () => practise.forEach(el => el.style.display = 'none'));
</script>
</body>
</html>
