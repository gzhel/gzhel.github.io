<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../styles.css">
    <title>Тематические разделы</title>
</head>
<body>
<div class="learn-page__layout checklist" style="padding-bottom: 50px;">
    <h1><a href="../index.html" style="color: aliceblue;">Back to main page</a></h1>
    <section class="learn-page__layout--study-block">
        <h3>Обозначения (субъективно):</h3>
        <div><span class="blue">Синий</span>: актуально, не очевидно, secret knowledge</div>
        <div><span class="green">Зеленый</span>: актуально, стоит изучать внимательно</div>
        <div><span style="color: red">Красный</span>: допустимо, в 99% случаев не используется</div>
        <div><span class="violet">Фиолетовый</span>: актуально, расширенный полезный материал</div>
        <div style="margin-bottom: 6px;"><span class="orange">Оранжевый</span>: пока не понятно, в процессе изучения материала</div>
        <div>
            <span><button id="show_reds">Показать "красные" пункты</button></span>
            <span><button id="hide_reds">Скрыть "красные" пункты</button></span>
            <span><button id="hide_for_what">Скрыть разделы "Зачем?"</button></span>
            <span><button id="hide_practise">Скрыть разделы "Практика"</button></span>
        </div>
    </section>
    <section class="learn-page__layout--study-block">
        <div class="text" style="background-color: white;">
            <b>1) Основные понятия</b><hr>
            <div>
                <input type="checkbox" name="1_1" id="1_1">
                <label for="1_1">1.1 Знакомство с JSX</label>
                <p class="for-what">Зачем мне нужен JSX? Делает работу с разметкой страницы наглядее, если бы не он, то нужно было бы писать React.createElement(...)</p>
                <ul>
                    <li>В JSX мы пишем код похожий на HTML, если бы не он, то нужно было бы писать React.createElement(type, props, children)</li>
                    <li>Внутри тегов JSX можно добавить любой код (if, строки, числа, функции итд), делается это через {fieldName}</li>
                    <li>JSX можно использовать для маппинга, вместе с if (и a ? b : c), и JSX можно присвоить переменной (т.к. JSX становится JS объектом)</li>
                    <li>Атрибуты (props) в JSX пишутся через camelCase, строки нужно присваивать через ="", а не ={""}, переменные через ={varName}</li>
                    <li>Все данные для отображения внутри JSX {} преобразуются в строки, что защищает от выполнения левых скриптов</li>
                    <li>Стоит понимать что JSX это простые теги вроде div, "компонент" же это функция, которая, как правило использует JSX</li>
                    <li class="violet">Продвинутая тема этого раздела №1: https://ru.reactjs.org/docs/react-without-jsx.html</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_2" id="1_2">
                <label for="1_2">1.2 Рендеринг элемента в DOM</label>
                <p class="for-what">Зачем мне это нужно? Если этого не знать, то можно словить множество сайд-эффектов, это то, зачем нужна мемоизация</p>
                <ul>
                    <li>React-элемент это не React-компонент, элемент это кусочек с JSX, компонент это функция, состоящая из этих элементов</li>
                    <li>В каждом React-приложении есть html файлик и в нём где-то есть div с id "root" или "mountNode", и на самом деле в приложении их может сколько угодно</li>
                    <li>Для того чтобы зарендерить какой-то "элемент" или "компонент" используют ReactDOM.render(element, document.getElementById('mountNode'))</li>
                    <li>Элементы иммутабельны, то есть как некое "фото" или "кадр", при смене состояния "фото1" сравнивается с "фото2" и меняет только то, что поменялось</li>
                    <li>Порядок изменения состояния следующий: есть "фото1" оно отрисовано в DOM, состояние поменялось, появилось "фото2", сравнили их, отрисовали изменения в DOM</li>
                    <li>Стоит понять самое главное: на каждое изменение создаётся абсолютно новый компонент, но в DOM изменится лишь разница между компонент1 и компонент2</li>
                    <li class="violet">Продвинутая тема этого раздела №1: https://ru.reactjs.org/docs/react-dom.html</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_3" id="1_3">
                <label for="1_3">1.3 Компоненты и пропсы</label>
                <p class="for-what">Зачем мне нужны "компоненты"? Компоненты позволяют разбить приложение на мелкие части, модули, с которыми легко работать по отдельности</p>
                <ul>
                    <li>React-компонент похож на обычную JS-функцию, он может принимать некие props, которые являются данными из вне, и возвращает JSX с тем, что мы хотим видеть</li>
                    <li>Классовые компоненты устарели, сейчас пишут на функциональных, которые гораздо более компактные, и используют React-хуки, вместо методов класса</li>
                    <li>Аналогично React-элементам, компоненты можно записать в переменную, и использовать например как a ? B : C, отрисовав нужный по условию компонент</li>
                    <li>Внутри компонента можно использовать компоненты, причём можно использовать одинаковые компонеты с разными props, а также один компонент несколько раз подряд</li>
                    <li>Декомпозиция это важный принцип в React, поэтому если нужно разбить компонент на более мелкие компоненты, то это стоит сделать</li>
                    <li>Props это данные для компонента из вне (строки, функции итд), не следует "мутировать" пропсы внутри компонента, компоненты должны быть как чистые функции</li>
                    <li class="violet">Продвинутая тема этого раздела №1: https://ru.reactjs.org/docs/react-component.html</li>
                    <li class="violet">Продвинутая тема этого раздела №2: https://ru.reactjs.org/docs/jsx-in-depth.html</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_4" id="1_4">
                <label for="1_4">1.4 Состояние и жизненный цикл</label>
                <p class="for-what">Зачем мне это нужно? Приложение не статическое, поэтому у него должно быть состояние, жизненный цикл это эффекты, за которые можно цепляться</p>
                <ul>
                    <li>Как было раньше №1? В классовом компоненте состояние зависело от this.state в constructor и this.setState(), доступ к props осуществлялся через this.props</li>
                    <li>Как было раньше №2? Были методы жизненного цикла: componentDidMount/Update (на монтирование/на изм. сост.), componentWillUnmount (на размонтирование)</li>
                    <li>Как было раньше №3? Чтобы использовать методы класса, нужно было из забиндить в constructor через this.methodName = this.methodName.bind(this)</li>
                    <li>Как стало теперь №1, 2, 3? Используется хук useState, this не нужен, хук useEffect вместо методов ЖЦ, биндить внутренние функции не нужно</li>
                    <li>Порядок выполнения: передаём "компонент" в ReactDOM.render(), компонент рендерится, как только компонент в DOM, срабатывает componentDidMount</li>
                    <li>Изменять состояние напрямую нельзя, только через setState, если принебречь этим, состояние изменится, но ререндер не будет совершён (!!! перепроверить !!!)</li>
                    <li>Можно представить содержимое для state как объект со всеми нужными полями, тогда состояние будет меняться следующим образом: setState({...state, field: 1})</li>
                    <li>Не стоит полагаться на state внутри setState, вместо этого, нужно добавить функцию в setState и там достать prevState: setState((prev) => {...prev, field: 1})</li>
                    <li>UPD: важное замечание, мы могли делать большие объекты в классовом state, в новом state получим ошибки, поэтому такая записаь актуальна: setState(pr => pr + 1)</li>
                    <li>В React "однонаправленный" и "нисходящий" поток данных, т.е. props можно прокинуть только дочерним компонентам, это называется "props drilling"</li>
                    <li>Последний момент, о котором стоит упомянуть в этом разделе: в JSX у каждого экземпляра компонента своё состояние, независимое от других экземпляров</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_5" id="1_5">
                <label for="1_5">1.5 Обработка событий</label>
                <p class="for-what">Зачем мне это нужно? В JSX пособ обработки событий сильно отличается от того, что есть в JavaScript, события диктуют динамику на странице</p>
                <ul>
                    <li>В React функции пишут через camelCase, также в JSX передаём функцию, а не строку: onclick="doIt()" -> onClick={doIt} (JS и JSX)</li>
                    <li>Важный момент, нельзя передавать функцию как onClick={doIt()}, так она вызовется сразу, но можно сделать ={doIt} или ={() => doIt()} это равносильная запись</li>
                    <li>В JS на form submit обновлялась страница, чтобы обновления не было в React, нужно на функцию которая идёт на submit вешать e.preventDefault()</li>
                    <li>В JS чтобы добавить событие на дейстие, был нужен addEventListener, в React он не нужен, и можно сразу добавлять функцию внурть действия (onClick итд)</li>
                    <li class="violet">Продвинутая тема этого раздела №1: https://ru.reactjs.org/docs/events.html</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_6" id="1_6">
                <label for="1_6">1.6 Условный рендеринг (отображение JSX по условию)</label>
                <p class="for-what">Зачем мне это нужно? Используется повседневно, когда нужно прятать или показывать элемент в зависимости от состояния</p>
                <ul>
                    <li>В зависимости от условия (флажка, любого другого объекта) можно отрисовать тот или иной компонент, это делается либо через if, либо через тернарный оператор</li>
                    <li>Стоит понимать, что "компонент" всегда возвращает JSX, и точно так же как в обычной функции, если сработал return, то до следующего return код не дойдёт</li>
                    <li>Как правило if (isOne) {return Component1} делается перед "основным" return, если используем тернарный оператор, он используется внутри {} в JSX {isA ? A : B}</li>
                    <li>Если нужно предотвратить рендеринг компонента, нужно добавить if (isA) return null, либо return isA ? null : Component, при этом методы ЖЦ всё равно сработают</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_7" id="1_7">
                <label for="1_7">1.7 Списки (массивы) и ключи</label>
                <p class="for-what">Зачем мне это нужно? Когда нужно показать несколько компонентов с данными, используют Array.map(), ключи это идентификаторы для React</p>
                <ul>
                    <li>Если нужно отрисовать несколько одинаковых JSX элементов или компонентов, наполненных различными данными, используют Array.map(): Bees.map(bee => Bee with props)</li>
                    <li>У каждого элемента или компонента после .map должен быть уникальный props "key" (строка), они нужны чтобы React мог сопоставлять элементы при изменении массива</li>
                    <li class="violet">Продвинутая тема этого раздела №1: https://ru.reactjs.org/docs/reconciliation.html</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_8" id="1_8">
                <label for="1_8">1.8 Формы</label>
                <p class="for-what">Зачем мне нужны формы? Это основной способ отправки данных с фронтенда на бекенд</p>
                <ul>
                    <li>Как можно узнать из HTML, у тега form есть состояние, которое она собирает по name инпутов (итд), а далее отправляет это состояние на бекенд по нажатию button submit</li>
                    <li>В данном формате мы никак не обрабатываем условные "onInputChange" и "onSubmit", всё происходит автоматически, это назвывается "неуправляемыми" компонентами</li>
                    <li>Повесив на условный "onInputChange" функцию-обработчик, которая запишет изменение состояния через setState в state, этот компонент станет "управляемым"</li>
                    <li>Всё что нужно понимать: value теперь это некий state, onChange теперь делает некий setState, компонент стал управляемым, это называется "двухстороннее связывание"</li>
                    <li>Исходя из предыдущего пункта: value это state, меняем state, изменение должно отобразиться, древо 1 сравнивается с древом 2, DOM ререндерит разницу с актуальным древом</li>
                    <li>У тега select немного по-другому: внутри него есть теги option с value, "управляемость" вешается на select, если хотим мультиселект, то value должен быть массивом</li>
                    <li>У input type file значение (фото, документ итд) доступно только для чтения, он позволяет загрузить файл на сервер, но является "неуправляемым"</li>
                    <li>В HTML мы собираем состояние полей по "name", в JSX тоже, но в state записываем как setState([event.target.name]: event.target.value), onChange всегда принимает event</li>
                    <li>В редких случаях, когда писать кучу обработчиков утомительно, используют "неуправляемые" компоненты через useRef (см. главу "Неуправляемые компоненты")</li>
                    <li>Полноценные решения для "управляемых" компонентов это библиотеки: Formik для форм, MobX или Redux для обращения с состоянием форм</li>
                    <li class="violet">Продвинутая тема этого раздела №1: https://ru.reactjs.org/docs/uncontrolled-components.html</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_9" id="1_9">
                <label for="1_9">1.9 Подъём состояния</label>
                <p class="for-what">Зачем мне нужно поднимать состояние? В нативном React на это могут быть причины, но сейчас есть множество библиотек вроде MobX, Redux, что решает проблему</p>
                <ul>
                    <li>Но ладно, представим ситуацию что Redux не существует... тогда в дочерних компонентах нужно через props от родителя принимать state и функцию наподобие setState</li>
                    <li>То есть мы меняем состояние в дочернем компоненте через проброс колбека от родителя, само же состояние находится в родителе, но его можно отображать и в дочернем компоненте</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_10" id="1_10">
                <label for="1_10">1.10 Композиция против наследования</label>
                <p class="for-what">Зачем мне это нужно? Наследование - в рамках JS не нужно, а композиция нужна для создания различных но похожих компонентов на базе "основного" компонента</p>
                <ul>
                    <li>Если мы хотим создать обёртку для компонента, который будет получен извне, то внутри JSX этой обёртки должен быть объект {children} доступный из props у всех компонентов</li>
                    <li>Композиция: "частный" компонент рендерит "общий" компонент и настраивает его с помощью пропсов WelcomeDark с props -> Welcome который откуда-то получает props и выводит их</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_11" id="1_11">
                <label for="1_11">1.11 Философия React</label>
                <p class="for-what">Зачем мне это нужно? React это приложение, состоящее из кубиков LEGO, отдельный кубик - отдельная жизнь внутри него, он самостоятелен, декомпозирован</p>
                <ul>
                    <li>Шаг 1: у нас есть макет, разбиваем макет на "компоненты" будущего интерфейса, даём имена этим компонентам, и не забываем про декомпозицию</li>
                    <li>Шаг 2: у нас есть план "на листочке" с названиями компонентов, создаём по этому плану статическое приложение, заполненное mock данными</li>
                    <li>Шаг 3: у нас есть статическое приложение, решаем, как будем хранить состояние, делаем приложение динамическим, добавляем изменение состояния</li>
                    <li>Шаг 4: у нас есть динамическое приложение, добавляем обработчики запросов/ответов на сервер и надеемся, что мы используем FLUX, а не обратный поток данных</li>
                    <li>Шаг 5: у нас есть динамическое и главное клиент-серверное приложение, радуемся жизни...</li>
                    <li class="violet">Продвинутая тема этого раздела №1: https://ru.reactjs.org/docs/faq-state.html</li>
                    <li>
                        Список продвинутых тем из раздела "Основные понятия": <br>
                        https://ru.reactjs.org/docs/jsx-in-depth.html <br>

                    </li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_12" id="1_12">
                <label for="1_12">1.12 Дополнительно</label>
                <p class="for-what">Зачем? ...</p>
                <ul>
                    <li class="violet">MPA (multi): куча файлов HTML, каждый сам по себе обладает какой-то логикой, каждый файл это отдельная страница</li>
                    <li class="violet">SPA (single): есть один mountNode, всё остальное это дочерние элементы для mountNode компонента</li>
                    <li class="violet">В React есть "дерево React элементов" (Virtual DOM), когда в нём что-то меняется, React строит новое дерево элементов с новыми значениями, и сравнивает его с предыдущим (а уже после добавляет в DOM), это называется "Согласование" (Reconciliation)</li>
                    <li class="violet">Файлы содержащие JSX создаются с расширением .jsx, .tsx, чтобы создать FC в WebStorm пишем rsc и жмём Tab</li>
                    <li class="violet">Файл называется так же как и компонент в нём, компонент обязательно должен возвращать какой-то JSX, компонент нужно экспортить</li>
                    <li class="violet">У классового (устаревшего) компонента в constructor есть 3 сущности: super(props), this.state = {...} и бинды для функций</li>
                    <li class="violet">Хуки: useState/Effect/Ref/Memo/Callback/Context это функции, их можно использовать в FC или внутри кастомных хуков, только на верхнем уровне вложенности, не можем вкладывать в {}, функции итд</li>
                    <li class="violet">Браузер добавляет свои стили, их нужно обнулить в файле стилей через * {margin: 0; padding: 0; box-sizing: border-box;}</li>
                    <li class="violet">Модули CSS: ComponentName.module.css, классы через camelCase, импорт как s from 'xxx.module.css', className={s.styleName}</li>
                    <li class="violet">Пропс под названием {children} обозначает дочерний узел в компоненте реакта, то есть Comp1 CompChild Comp1</li>
                    <li class="violet">Если пропсов много, их можно передать как ({...props}), а также развернуть внутри JSX узла как {...props}</li>
                    <li class="violet">Чтобы получить данные из неуправляемого инпута нужен useRef, он даст доступ к DOM-элементу и у него можно будет забрать value</li>
                    <li class="violet">Чтобы передать Ref в дочерний компонент, его нужно обернуть в forwardRef(), тогда вторым параметром у компонента будет ref</li>
                    <li class="violet">В setState если state это массив, то если мы не хотим затирать предыдущий state, пишут так setState([...state, newState])</li>
                    <li class="violet">Если нужно, изменить поле объекта, но оставить в порядке другие поля запись следующая {...fields, field5: 'something'}</li>
                    <li class="violet">Чтобы передать данные от ребёнка к родителю, нужно из родителя передать колбэк функцию в дочерний компонент и в дочернем передать в этот колбэк изменённые данные</li>
                    <li class="violet">Чтобы создать сортировку нужен селект, который содержить названия полей, по которым будем сортировать, используем фунцию a.localeCompare(b)</li>
                    <li class="violet">При изменению инпута на каждый нажатый символ меняется state, тут помогает useMemo(callback, deps) - callback должен возвращать результат каких-то вычислений</li>
                    <li class="violet">Как работает useMemo: производит вычисление 1 раз, запоминает результат вычисления и кэширует, на каждую перерисовку компонента вычисление не будет производиться вновь, но каждый раз когда меняется deps, функция вновь пересчитывает и кэширует уже новый результат</li>
                    <li class="violet">Для анимаций у React есть библиотека "react-transition-group", этот компонент является обёрткой, элементы обёрнуты в CSSTransition, нужно копировать стили либы в CSSTransition</li>
                    <li class="violet">В кастомные хуки можно добавлять логику которая была на верхнем уровне Компонента и имела на верхнем уровне обычные хуки, нужны для декомпозиции и в целом всё</li>
                    <li class="violet">Для работы с сервером обычно используют axios, для этого достаточно axios.get(), axios.post(), то что нам нужно находится в response.data</li>
                    <li class="violet">Жизненный цикл компонента состоит из трёх стадий: mount, update, unmount, и всех их можно обработать в useEffect, при этом useEffect можно использовать несколько раз в одном компоненте</li>
                    <li class="violet">Все API стоит выносить в отдельные файлы типа xxx.service, который будет является классом, а запрашиваемые данные будут static async методами</li>
                    <li class="violet">Query параметры указываются полсе знака "?", разделяются знаком "&", например: /posts?_limit=5&_page=2</li>
                    <li class="violet">Есть следующие виды Query-параметров: _limit=N (кол-во JSON объектов), _page=N (номер страницы), x-total-count в Network запросе это общее кол-во объектов, которое может вернуть сервер</li>
                    <li class="violet">В axios после URL вторым параметром можно указать params, где как раз можно вписать _limit и _page, там же можно достать из response.headers['x-total-count'] и поделить его на limit, тогда мы узнаем, сколько страниц должно быть в пагинации (не забыть обернуть в Math.ceil)</li>
                    <li class="violet">Изменение состояния это асинхронный процесс !!! то есть если мы в рамках одного метода changePage(page) {setPage(page); fetchPosts();} сменили page через setPage, а fetchPosts() использует этот page, то он получит старое состояние page</li>
                    <li class="violet">Как это исправить? Сделать эффект, т.е. добавить useEffect, который делает fetchPosts() если меняется [page] в deps</li>
                    <li class="violet">Как исправить без useEffect? Сделать changePage(page) {setPage(page); fetchPosts(limit, page);} и внутри fetchPosts в асинхронную функцию fetching передать ...args и в callback передать ...args, т.к. кол-во аргументов неизвестно</li>
                    <li class="violet">Переиспользуемость это очень важно, поэтому стоит декомпозировать код</li>
                    <li class="violet">Для навигации по страницам в React исползуют react-router-dom (не путать с react-router), нужно App обернуть в BrowserRouter, для навигации используется Route с path по которому страница должна отрисовываться</li>
                    <li class="violet">На этом же этапе можно добавить какой-то Layout, или Navbar, которые будут являться обёрткой для роутов</li>
                    <li class="violet">Для переключения страниц нужно использовать Link вместо тега "a", вместо href будет to, тогда переходы между страницами будут без перезагрузки страницы</li>
                    <li class="violet">Route компоненты нужно обернуть в Switch, если ни один из маршрутов не сработает, то сработает Redirect на страницу с ошибкой</li>
                    <li class="violet">Редиректы можно делать не только через Link и Redirect, но и ещё через history.push('/') из useHistory() из 'react-router-dom' НЕ ИЗ 'react'</li>
                    <li class="violet">Хук useParams из 'react-router-dom' возвращает объект с параметрами из URL (id и так далее), подходит для получения данных с сервера по ID</li>
                    <li class="violet">Приватные и публичные маршруты: можно создать export const privateRoutes, содержащий объекты типа {path: ..., component: ..., exact: ...}, роуты будут добавляться как router.map(route => Route with route props)</li>
                    <li class="violet">Для публичных роутов (как правило это страница Логина) нужно создать другой массив, а в компоненте Router достать какой-то флажок типа "isAuth" и отрисовывать privateRoutes только если этот флажок true</li>
                    <li class="violet">Для доступа к "глобальным переменным" используют либо shared store, либо useContext, глобальные данные передаются в Context, из контекста куда угодно</li>
                    <li class="violet">Но тут есть проблема: при обновлении страницы все стейты сбрасываются, поэтому их нужно где-то хранить, например в localStorage, если ключ есть в LS, то ставим isAuth true</li>
                    <li class="violet">В случае когда мы авторизируемся, не нужно показывать Routes, поэтому если так, то просто возвращает какой-то прелоадер</li>
                    <li class="violet">Чтобы сделать бесконечную ленту нужно помещать данные в конец тех, что уже есть, т.е. setData([...oldData, ...newData]), подобный функционал помогает сделать Observer API</li>
                    <li class="violet">Для такой загрузки в самом низу страницы можно создать невидимый блок, доходя до которого будет происходить подгрузка данных, для получения этого элемента используют useRef(), далее используем код из Observer API</li>
                </ul>
            </div>
            <div>
                <p class="helpful" style="padding: 10px;">
                    <span>Практика: </span><a href="https://jsfiddle.net/gzhel/zpgkfvLm/143/" target="_blank">DOM, BOM, высота, скроллы</a>
                </p>
            </div>
        </div>
    </section>
</div>
<script>
    const showReds = document.querySelector("#show_reds");
    const hideReds = document.querySelector("#hide_reds");
    const reds = document.querySelectorAll('.hidden');
    showReds.addEventListener('click', () => reds.forEach(red => red.tagName === "LI"? red.style.display = 'list-item' : red.style.display = 'block'));
    hideReds.addEventListener('click', () => reds.forEach(red => red.style.display = 'none'));

    const hideForWhat = document.querySelector("#hide_for_what");
    const forWhat = document.querySelectorAll(".for-what");
    hideForWhat.addEventListener('click', () => forWhat.forEach(el => el.style.display = 'none'));

    const hidePractise = document.querySelector("#hide_practise");
    const practise = document.querySelectorAll(".helpful");
    hidePractise.addEventListener('click', () => practise.forEach(el => el.style.display = 'none'));
</script>
</body>
</html>
