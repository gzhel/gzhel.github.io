<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../styles.css">
    <title>Тематические разделы</title>
</head>
<body>
<div class="learn-page__layout checklist" style="padding-bottom: 50px;">
    <h1><a href="../index.html" style="color: aliceblue;">Back to main page</a></h1>
    <section class="learn-page__layout--study-block">
        <h3>Обозначения (субъективно):</h3>
        <div><span class="blue">Синий</span>: актуально, не очевидно, secret knowledge</div>
        <div><span class="green">Зеленый</span>: актуально, стоит изучать внимательно</div>
        <div><span style="color: red">Красный</span>: допустимо, в 99% случаев не используется</div>
        <div><span class="violet">Фиолетовый</span>: актуально, расширенный полезный материал</div>
        <div style="margin-bottom: 6px;"><span class="orange">Оранжевый</span>: пока не понятно, в процессе изучения материала</div>
        <div>
            <span><button id="show_reds">Показать "красные" пункты</button></span>
            <span><button id="hide_reds">Скрыть "красные" пункты</button></span>
            <span><button id="hide_for_what">Скрыть разделы "Зачем?"</button></span>
            <span><button id="hide_practise">Скрыть разделы "Практика"</button></span>
        </div>
    </section>
    <section class="learn-page__layout--study-block">
        <div class="text" style="background-color: white;">
            <b>1) Основные понятия</b><hr>
            <div>
                <input type="checkbox" name="1_1" id="1_1">
                <label for="1_1">1.1 Знакомство с JSX</label>
                <p class="for-what">Зачем? Делает работу с разметкой страницы наглядее, если бы не он, то нужно было бы писать React.createElement(...)</p>
                <ul>
                    <li class="green">Можно встраивать переменные в JSX, делается это через {fieldName}, в фигурных скобках могут быть любые допустимые JS выражения</li>
                    <li class="green">JSX-фрагмент можно использовать в циклах, вместе с if и для присваивания переменной</li>
                    <li class="blue">В JSX атрибуты пишутся через camelCase, строки нужно присваивать через ="", а не ={""}, переменные через ={varName}</li>
                    <li class="blue">В JSX все данные для отображения преобразуются в строки, что защищает от выполнения левых скриптов</li>
                    <li class="violet">В JSX мы пишем код похожий на HTML, вместо него были бы React.createElement(type, props, children)</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_2" id="1_2">
                <label for="1_2">1.2 Рендеринг элемента в DOM</label>
                <p class="for-what">Зачем? Позволяет понять, что происходит во время изменения состояния компонента</p>
                <ul>
                    <li class="blue">В React-приложении может быть сколько угодно root-элементов, но обычно один, который создаётся через ReactDOM.render(app, root)</li>
                    <li class="blue">При смене состояния, React сравнивает компонент и все его поля с их предудущей версией, и ререндерит только измененные элементы</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_3" id="1_3">
                <label for="1_3">1.3 Компоненты и пропсы</label>
                <p class="for-what">Зачем? Компоненты позволяют разбить приложение на мелкие части, модули, с которыми легко работать по отдельности</p>
                <ul>
                    <li class="green">Сейчас в основном код пишут на функциональных компонентах вида const Welcome = (props) => <\div>{props.name}<\/></li>
                    <li class="blue">React-компоненты могут содержать "пропсы", которые можно использовать внутри компонента: <\Welcome name="Alex" \/></li>
                    <li class="green">React-компоненты могут переиспользоваться с разными пропсами, а также много раз использоваться в другом компоненте</li>
                    <li class="green">Можно дробить React-компоненты на более мелкие, можно хоть прям супер мелко раздробить, но только если это нужно</li>
                    <li class="blue">Правило: React-компоненты должны вести себя как чистые функции в отношении своих пропсов, т.е. не изменять их</li>
                    <li class="violet">Пропсы это данные для компонента из вне, также когда мапим данные, index как ключ использовать не рекомендуется</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_4" id="1_4">
                <label for="1_4">1.4 Состояние и жизненный цикл</label>
                <p class="for-what">Зачем? Приложение не статическое, поэтому у него должно быть состояние, жизненный цикл это эффекты, за которые можно цепляться</p>
                <ul>
                    <li class="green">В классовом компоненте со стейтом управлялись через this.state в constructor и this.setState(), в FC через useState()</li>
                    <li class="green">Методы жизненного цикла: componentDidMount/Update (на монтирование/на изм. сост.), componentWillUnmount (на размонтирование)</li>
                    <li class="blue">Правила состояний: не изменять напрямую (только setState), в setState использовать prevState, один setState - одно поле state</li>
                    <li class="green">Состояние компонента локально, но можно делать prop drilling, передавая состояние родителя дочерним компонентам</li>
                    <li class="blue">Правило: React-компоненты должны вести себя как чистые функции в отношении своих пропсов, т.е. не изменять их</li>
                    <li class="violet">Если мы меняем значение let, то React не поймёт изменений и не совершит ререндер изменяемого компонента</li>
                    <li class="violet">const [state, setState] = useState(initialValue), в современном React состояние меняется так setState(newValue)</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_5" id="1_5">
                <label for="1_5">1.5 Обработка событий</label>
                <p class="for-what">Зачем? Теперь тут заправляет JSX, и мы передаём функции-обработчики уже JSX компонентам, а не HTML элементам</p>
                <ul>
                    <li class="green">В JSX собыитя передаются почти так же как в HTML, он они camelCase и передаются как doIt, а не "doIt()"</li>
                    <li class="blue">Чтобы в JSX функции-обработчике отменить поведение по умолчанию, нужно добавить e.preventDefault() в сам обработчик</li>
                    <li class="green">В JSX не нужен addEventListener, можно вешать обработчик прямо на элемент, либо ссылку на обработчик в компоненте</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_6" id="1_6">
                <label for="1_6">1.6 Условный рендеринг (отображение элемента по условию)</label>
                <p class="for-what">Зачем? Используется очень часто, когда нужно прятать или показывать элемент в зависимости от условия</p>
                <ul>
                    <li class="green">В зависимости от условия (флажка, поля из данных итд) можно отрисовать тот или иной компонент</li>
                    <li class="green">Компоненты можно сохранять в переменные по условию, но это также можно сделать и внутри блока {isA ? A : B}</li>
                    <li class="green">Внутри JSX (т.е. компонента вида <\ComponentA/> можно заключить внутрь {} любые данные и условия</li>
                    <li class="blue">Чтобы предотвратить рендеринг (НЕ показать компонент), нужно условие if по которому будет возвращён null</li>
                    <li class="blue">Тем не менее, даже если компонент не отрисует свой return, методы его жизненного цикла сработают</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_7" id="1_7">
                <label for="1_7">1.7 Списки и ключи</label>
                <p class="for-what">Зачем? Когда нужно показать несколько компонентов с данными, используют Array.map(), ключи это идентификаторы для React</p>
                <ul>
                    <li class="green">Если нужно показать несколько одинаковых по HTML элементов или компонентов с разными данными, используют Array.map()</li>
                    <li class="green">У каждого "родительского" элемента в .map должен быть уникальный по значению props под названием key (строковый)</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_8" id="1_8">
                <label for="1_8">1.8 Формы</label>
                <p class="for-what">Зачем? Для хранения данных, отправки данных на бекенд</p>
                <ul>
                    <li class="blue">Если в HTML формы сами хранят свой state, то в React обычно используют state и setState</li>
                    <li class="green">Чтобы сделать элемент формы "управляемым", он должен иметь поля вроде onChange или onSubmit, и мы должны их обработать</li>
                    <li class="blue">На примере инпута, каждый введенный символ вызывает функцию onChange, а значит ререндерит компонент инпута</li>
                    <li class="green">В <\select> есть <\option> с полем value, который определяется через value элемента <\select></li>
                    <li class="blue">input file позволяет загрузить файл с устройства на сервер, его значение доступно только для чтения (неуправляемый)</li>
                    <li class="green">В случае, если у нас несколько инпутов, им нужен name, чтобы была записать типо setState({[evt.target.name]: value})</li>
                    <li class="blue">setState делает слияние части с ключом A в объект state, при этом в state могут быть и другие значения</li>
                    <li class="violet">Управляемый компонент это тот, условно value и onChange которого зависят от [state, setState] = useState()</li>
                    <li class="violet">Двухстороннее связывание это связывание стейта React со стейтом элемента (например инпута) в DOM</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_9" id="1_9">
                <label for="1_9">1.9 Подъём состояния</label>
                <p class="for-what">Зачем? Состояние дочерних компонентов могут понадобиться внутри родительских например чтобы их сравнить</p>
                <ul>
                    <li class="blue">Подъём состояния это бред, такие вещи стоит делать через Redux или Context (если мы не хотим писать много кода)</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_10" id="1_10">
                <label for="1_10">1.10 Композиция против наследования</label>
                <p class="for-what">Зачем? Теоретическое знание, просто чтобы понять что есть что и не писать плохой код</p>
                <ul>
                    <li class="blue">Композиция - "частный" компонент рендерит "общий" компонент и настраивает его с помощью пропсов WelcomeDark -> Welcome</li>
                    <li class="green">Если мы пока не знаем что за дочерний компонент, можно использовать {children}, который есть у всех компонентов</li>
                    <li class="blue">Наследование - лучше не знать и не использовать, в React это просто ненужное усложенеие жизни себе и другим</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_11" id="1_11">
                <label for="1_11">1.11 Философия React</label>
                <p class="for-what">Зачем? React это приложение по кубикам лего, отдельный кубик - отдельная микрожизнь внутри него, он самостоятелен</p>
                <ul>
                    <li class="green">Шаг 1: разбить макет на составляющие будущего интерфейса, дать имена этим компонентам, 1 компонент - 1 задача</li>
                    <li class="green">Шаг 2: создать статическое приложение на основе этих компонентов, просто статика, данные можно через пропсы (не state)</li>
                    <li class="green">Шаг 3: делаем минимальную динамику фиче, при помощи state</li>
                    <li class="green">Шаг 4: определяемся, где должно находиться состояние, это может быть родитель, но я считаю что самостоятельные модули лучше</li>
                    <li class="green">Шаг 5: добавление обратного потока данных, которое не актуально, если мы используем самостоятельные модули из пункта выше</li>
                    <li class="blue">По факту: разбить макет на компоненты, сделать статику, сделать FLUX подход, шаги выше это очень усложнённый вариант</li>
                </ul>
            </div>
            <div>
                <input type="checkbox" name="1_12" id="1_12">
                <label for="1_12">1.12 Дополнительно</label>
                <p class="for-what">Зачем? ...</p>
                <ul>
                    <li class="violet">MPA (multi): куча файлов HTML, каждый сам по себе обладает какой-то логикой, каждый файл это отдельная страница</li>
                    <li class="violet">SPA (single): есть один mountNode, всё остальное это дочерние элементы для mountNode компонента</li>
                    <li class="violet">В React есть "дерево React элементов" (Virtual DOM), когда в нём что-то меняется, React строит новое дерево элементов с новыми значениями, и сравнивает его с предыдущим (а уже после добавляет в DOM), это называется "Согласование" (Reconciliation)</li>
                    <li class="violet">Файлы содержащие JSX создаются с расширением .jsx, .tsx, чтобы создать FC в WebStorm пишем rsc и жмём Tab</li>
                    <li class="violet">Файл называется так же как и компонент в нём, компонент обязательно должен возвращать какой-то JSX, компонент нужно экспортить</li>
                    <li class="violet">У классового (устаревшего) компонента в constructor есть 3 сущности: super(props), this.state = {...} и бинды для функций</li>
                    <li class="violet">Хуки: useState/Effect/Ref/Memo/Callback/Context это функции, их можно использовать в FC или внутри кастомных хуков, только на верхнем уровне вложенности, не можем вкладывать в {}, функции итд</li>
                    <li class="violet">Браузер добавляет свои стили, их нужно обнулить в файле стилей через * {margin: 0; padding: 0; box-sizing: border-box;}</li>
                    <li class="violet">Модули CSS: ComponentName.module.css, классы через camelCase, импорт как s from 'xxx.module.css', className={s.styleName}</li>
                    <li class="violet">Пропс под названием {children} обозначает дочерний узел в компоненте реакта, то есть Comp1 CompChild Comp1</li>
                    <li class="violet">Если пропсов много, их можно передать как ({...props}), а также развернуть внутри JSX узла как {...props}</li>
                    <li class="violet">Чтобы получить данные из неуправляемого инпута нужен useRef, он даст доступ к DOM-элементу и у него можно будет забрать value</li>
                    <li class="violet">Чтобы передать Ref в дочерний компонент, его нужно обернуть в forwardRef(), тогда вторым параметром у компонента будет ref</li>
                    <li class="violet">В setState если state это массив, то если мы не хотим затирать предыдущий state, пишут так setState([...state, newState])</li>
                    <li class="violet">Если нужно, изменить поле объекта, но оставить в порядке другие поля запись следующая {...fields, field5: 'something'}</li>
                    <li class="violet">Чтобы передать данные от ребёнка к родителю, нужно </li>
                </ul>
            </div>
            <div>
                <p class="helpful" style="padding: 10px;">
                    <span>Практика: </span><a href="https://jsfiddle.net/gzhel/zpgkfvLm/143/" target="_blank">DOM, BOM, высота, скроллы</a>
                </p>
            </div>
        </div>
    </section>
</div>
<script>
    const showReds = document.querySelector("#show_reds");
    const hideReds = document.querySelector("#hide_reds");
    const reds = document.querySelectorAll('.hidden');
    showReds.addEventListener('click', () => reds.forEach(red => red.tagName === "LI"? red.style.display = 'list-item' : red.style.display = 'block'));
    hideReds.addEventListener('click', () => reds.forEach(red => red.style.display = 'none'));

    const hideForWhat = document.querySelector("#hide_for_what");
    const forWhat = document.querySelectorAll(".for-what");
    hideForWhat.addEventListener('click', () => forWhat.forEach(el => el.style.display = 'none'));

    const hidePractise = document.querySelector("#hide_practise");
    const practise = document.querySelectorAll(".helpful");
    hidePractise.addEventListener('click', () => practise.forEach(el => el.style.display = 'none'));
</script>
</body>
</html>
