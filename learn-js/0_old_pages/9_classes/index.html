<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../styles.css">
    <title>Классы</title>
</head>
<body>
    <div class="learn-page__layout">
        <h1><a href="../../0_old_pages/">Back to module 1</a></h1>
        <section class="learn-page__layout--study-block">
            <h3>Обозначения:</h3>
            <div class="text checked">Зеленый блок = прогресс изучения; Зеленая рамка = повторил, классно.</div>
            <div class="help helpful">Синий блок = полезная подсказка; Синяя рамка = очень важно, очень классно.</div>
            <div class="script useless">Красный блок = задача; Красная рамка = на мой взгляд не стоит внимания.</div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>9.1 Класс: базовый синтаксис</h3>
            <div class="text helpful">
                <b>Синтаксис «class»</b>
                <p>
                    Синтаксис: class MyClass {constructor() { ... } method1() { ... } method2() { ... } ...} <br><br>
                    Затем используйте вызов new MyClass() для создания нового объекта со всеми перечисленными методами. Пример: <br><br>
                </p>
                <img src="./img/1.png" alt="" width="100%">
                <p>
                    Когда вызывается new User("Иван"): Создаётся новый объект, constructor запускается с заданным аргументом и сохраняет его в this.name.<br><br>
                    …Затем можно вызывать на объекте методы, такие как user.sayHi().
                </p>
            </div>
            <div class="text helpful">
                <b>Что такое класс?</b>
                <p>
                    В JavaScript класс – это разновидность функции. Вот что на самом деле делает конструкция class User {...}:<br><br>
                    1) Создаёт функцию с именем User, которая становится результатом объявления класса. <br><br>
                    Код функции берётся из метода constructor (она будет пустой, если такого метода нет). <br><br>
                    2) Сохраняет все методы, такие как sayHi, в User.prototype. <br><br>
                    При вызове метода объекта new User он будет взят из прототипа: поля в User, методы в User.prototype.
                </p>
            </div>
            <div class="text checked">
                <b>Не просто синтаксический сахар</b>
                <p>
                    1) В отличие от обычных функций, конструктор класса не может быть вызван без new. <br><br>
                    2) Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable вfalse для всех методов в "prototype". <br><br>
                    И это хорошо, так как если мы проходимся циклом for..in по объекту, то обычно мы не хотим при этом получать методы класса. <br><br>
                    3) Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.
                </p>
            </div>
            <div class="text checked">
                <b>Геттеры/сеттеры, другие сокращения</b>
                <p>
                    Вот пример user.name, реализованного с использованием get/set:
                </p>
                <img src="./img/2.png" alt="" width="100%">
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>9.2 Наследование классов</h3>
            <div class="text helpful">
                <b>Основы</b>
                <p>
                    Для того, чтобы наследовать класс от другого, мы должны использовать ключевое слово "extends" и указать название родительского класса перед {..}. <br><br>
                    Ниже Rabbit наследует от Animal:
                </p>
                <img src="./img/3.png" alt="" width="100%">
                <p>
                    Ключевое слово extends работает, используя прототипы. Оно устанавливает Rabbit.prototype.[[Prototype]] в Animal.prototype. <br><br>
                    Так что если метод не найден в Rabbit.prototype, JavaScript берёт его из Animal.prototype.
                </p>
            </div>
            <div class="text checked">
                <b>Переопределение методов</b>
                <p>
                    Обычно мы не хотим полностью заменить родительский метод, а скорее хотим сделать новый на его основе, изменяя или расширяя его функциональность. <br></br>
                    Мы делаем что-то в нашем методе и вызываем родительский метод до/после или в процессе. <br><br>
                    У классов есть ключевое слово "super" для таких случаев: <br><br>
                    1) super.method(...) вызывает родительский метод. <br><br>
                    2) super(...) вызывает родительский конструктор (работает только внутри нашего конструктора).
                    Вот пример, где вызвали родительский stop() и наш hide():
                </p>
                <img src="./img/4.png" alt="" width="100%">
                <p>
                    У стрелочных функций нет super.
                </p>
            </div>
            <div class="text helpful">
                <b>Переопределение конструктора</b>
                <p>
                    Если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой «пустой» конструктор: <br><br>
                    class Rabbit extends Animal {constructor(...args) {super(...args);}} <br><br>
                    У Rabbit можно создать свой конструктор: constructor(name, earLength) {this.speed = 0;this.name = name;this.earLength = earLength;} <br><br>
                    Но мы получим ошибку. Почему? В классах-потомках конструктор обязан вызывать super(...), и (!) делать это перед использованием this. <br><br>
                    1) Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его this. <br><br>
                    2) Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса. <br><br>
                    Поэтому, если мы создаём собственный конструктор, мы должны вызвать super, в противном случае объект для this не будет создан, и мы получим ошибку. <br><br>
                    Вот так будет правильно: constructor(name, earLength) {super(name);this.earLength = earLength;}
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Ошибка создания экземпляра класса</b>
                <p>
                    Дочерний конструктор должен вызвать super и унаследовать от родительского конструктора: super(name)
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>9.3 Статические свойства и методы</h3>
            <div class="text useless">
                <b>Основы</b>
                <p>
                    Мы также можем присвоить метод самой функции-классу, а не её "prototype". Такие методы называются статическими. <br><br>
                    В классе такие методы обозначаются ключевым словом static, например: class User {static staticMethod() {alert(this === User);}} <br><br>
                    Это фактически то же самое, что присвоить метод напрямую как свойство функции: <br><br>
                    class User { } User.staticMethod = function() {alert(this === User);}; <br><br>
                    Обычно статические методы используются для реализации функций, принадлежащих классу, но не к каким-то конкретным его объектам. <br><br>
                    Представим, что нам нужно создавать статьи через создание пустой статьи с сегодняшней датой. Пример: 
                </p>
                <img src="./img/5.png" alt="" width="100%">
                <p>
                    Теперь каждый раз, когда нам нужно создать сегодняшний дайджест, нужно вызывать Article.createTodays(). <br><br>
                    Статические методы также используются в классах, относящихся к базам данных, для поиска/сохранения/удаления вхождений в базу данных.
                </p>
            </div>
            <div class="help checked">
                <b>Статические свойства</b>
                <p>
                    Статические свойства также возможны, они выглядят как свойства класса, но с static в начале: <br><br>
                    class Article {static publisher = "Илья Кантор";} alert( Article.publisher ); // Илья Кантор <br><br>
                    Это то же самое, что и прямое присваивание Article: Article.publisher = "Илья Кантор";
                </p>
            </div>
            <div class="help useless">
                <b>Наследование статических свойств и методов</b>
                <p>
                    Статические свойства и методы наследуются. <br><br>
                    Мы можем вызвать Rabbit.compare, при этом будет вызван унаследованный Animal.compare:
                </p>
                <img src="./img/6.png" alt="" width="100%">
            </div>
            <div class="script checked">
                <b>Задачи. Класс расширяет объект?</b>
                <p>
                    Унаследованный конструктор должен вызвать super(), т.к. в противном случае this будет неизвестен.
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>9.4 Приватные и защищённые методы и свойства</h3>
            <div class="text checked">
                <b>Внутренний и внешний интерфейсы</b>
                <p>
                    В объектно-ориентированном программировании свойства и методы разделены на 2 группы: <br><br>
                    1) Внутренний интерфейс – методы и свойства, доступные из других методов класса, но не снаружи класса. <br><br>
                    2) Внешний интерфейс – методы и свойства, доступные снаружи класса. <br><br><br>
                    В JavaScript есть два типа полей (свойств и методов) объекта: <br><br>
                    1) Публичные: доступны отовсюду. Они составляют внешний интерфейс. До этого момента мы использовали только публичные свойства и методы. <br><br>
                    2) Приватные: доступны только внутри класса. Они для внутреннего интерфейса.
                </p>
            </div>
            <div class="help helpful">
                <b>Защищённое свойство «waterAmount»</b>
                <p>
                    Защищённые свойства обычно начинаются с префикса _. <br><br>
                    Пример класса с НЕ защищённым waterAmount:
                </p>
                <img src="./img/7.png" alt="" width="100%">
                <p>
                    Пример класса с защищённым waterAmount:
                </p>
                <img src="./img/8.png" alt="" width="100%">
            </div>
            <div class="text checked">
                <b>Приватное свойство «#waterLimit»</b>
                <p>
                    Есть новшество в языке JavaScript, которое почти добавлено в стандарт: оно добавляет поддержку приватных свойств и методов. <br><br>
                    Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса. 
                </p>
                <img src="./img/9.png" alt="" width="100%">
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>9.5 Расширение встроенных классов</h3>
            <div class="text useless">
                <b>Основы</b>
                <p>
                    От встроенных классов, таких как Array, Map и других, тоже можно наследовать.
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>9.6 Проверка класса: "instanceof"</h3>
            <div class="text helpful">
                <b>Оператор instanceof</b>
                <p>
                    Оператор instanceof позволяет проверить, к какому классу принадлежит объект, с учётом наследования. <br><br>
                    Синтаксис: obj instanceof Class // true/false <br><br>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>9.7 Примеси</h3>
            <div class="text useless">
                <b>Основы</b>
                <p>
                    В JavaScript можно наследовать только от одного объекта.  <br><br>
                    Иногда это может ограничивать нас. Например, у нас есть класс StreetSweeper и класс Bicycle, 
                    а мы хотим создать их смесь: StreetSweepingBicycle. Для таких случаев существуют «примеси».<br><br>
                    Примесь примесь определяет методы, которые реализуют определённое поведение. 
                    Мы не используем примесь саму по себе, а используем её, чтобы добавить функциональность другим классам.
                </p>
            </div>
            <div class="text useless">
                <b>Пример примеси</b>
                <p>
                    Простейший способ реализовать примесь в JavaScript – это создать объект с полезными методами, 
                    которые затем могут быть легко добавлены в прототип любого класса. <br><br>
                    В примере ниже примесь sayHiMixin имеет методы, которые придают объектам класса User возможность вести разговор:
                </p>
                <img src="./img/10.png" alt="" width="100%">
                <p>
                    Это не наследование, а просто копирование методов. Таким образом, класс User может наследовать от другого класса, 
                    но при этом также включать в себя примеси, «подмешивающие» другие методы. <br><br>
                    Примеси могут наследовать друг друга.
                </p>
            </div>
        </section>
    </div>
</body>
</html>