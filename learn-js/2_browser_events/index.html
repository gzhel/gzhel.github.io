<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../styles.css">
    <title>Кратко про Браузер, document, events</title>
</head>
<body>
    <div class="learn-page__layout checklist" style="padding-bottom: 50px;">
        <h1><a href="../index.html" style="color: aliceblue;">Back to main page</a></h1>
        <section class="learn-page__layout--study-block">
            <h3>Обозначения (субъективно):</h3>
            <div><span class="blue">Синий</span>: актуально, не очевидно, secret knowledge</div>
            <div><span class="green">Зеленый</span>: актуально, стоит изучать внимательно</div>
            <div><span style="color: red">Красный</span>: допустимо, в 99% случаев не используется</div>
            <div><span class="violet">Фиолетовый</span>: актуально, расширенный полезный материал</div>
            <div style="margin-bottom: 6px;"><span class="orange">Оранжевый</span>: пока не понятно, в процессе изучения материала</div>
            <div>
                <span><button id="show_reds">Показать "красные" пункты</button></span>
                <span><button id="hide_reds">Скрыть "красные" пункты</button></span>
                <span><button id="hide_for_what">Скрыть разделы "Зачем?"</button></span>
                <span><button id="hide_practise">Скрыть разделы "Практика"</button></span>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>1) Документ</b><hr>
                <div>
                    <input type="checkbox" name="1_1" id="1_1">
                    <label for="1_1">1.1 Браузерное окружение, спецификации</label>
                    <p class="for-what">Зачем? Важное знание для того, чтобы понимать, как в целом происходят взаимодействия на любой странице браузера.</p>
                    <ul>
                        <li class="green">Окружение: раньше JS был только в браузере, сейчас он много где и это "где" называют "окружением" ("браузерное окружение")</li>
                        <li class="blue">window: это глобальный объект JS, и одновременно окно браузера и сущность содержащая методы управления окном браузера</li>
                        <li class="green">widow содержит 3 дочерних сущности: DOM (Document Object Model), BOM (Browset Object Model), JavaScript</li>
                        <li class="green">DOM (Document Object Model): это объект HTML файла страницы, который имеет методы работы с HTML этой страницы</li>
                        <li class="green">BOM (Browset Object Model): это объекты для работы со всем кроме документа (location, navigator, history, screen, frames)</li>
                        <li class="blue">Объекты BOM: location (о URL), navigator (о браузере), history (история переходов), screen (размеры экрана), frames (iframes)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="1_2" id="1_2">
                    <label for="1_2">1.2 DOM-дерево</label>
                    <p class="for-what">Зачем? Взаимодействие с html элементами через JavaScript, несмотря на фреймворки, бывает нужным.</p>
                    <ul>
                        <li class="blue">Каждый HTML-тег это имеет объект обёртку в DOM, меняем обёртку - меняется HTML-тег. Пример: document.body.style.color = "red"</li>
                        <li class="blue">DOM это древо HTML-тегов страницы, элементы называются узлами (nodes), текст называется текстовыми узламми (text nodes)</li>
                        <li class="green">DOM обладает автоисправлением: если мы напишем теги как-то неправильно, не закроем итд, оно исправит чтобы не было ошибки</li>
                        <li class="blue">Основные типы DOM-узлов: document, узлы-элементы (HTML-теги), текстовые узлы (текст), узлы-комментарии (комментарии)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="1_3" id="1_3">
                    <label for="1_3">1.3 Навигация по DOM-элементам</label>
                    <p class="for-what">Зачем? Большинство пунктов используется редко, но иногда бывает очень полезно, например children в React.</p>
                    <ul>
                        <li class="green">Все операции с DOM из нашего JavaScript начинаются с объекта document. Пример: document.body.parentNode</li>
                        <li class="blue">Дети: childNodes (список дочерних элементов), firstChild/lastChild (первый/последний дочерний элемент) </li>
                        <li class="green">DOM-коллекции: массивы элементов DOM это коллекции и им доступен for..of. Пример: for (let $el of childNodes) {alert($el)}</li>
                        <li class="blue">Соседи и родитель: соседи имеют общего родителя (nextSibling, previousSibling), родитель доступен через parentNode</li>
                        <li class="blue">Ссылки на только узлы-элементы: children (коллекция детей), parentElement (родитель-элемент), first/lastElementChild</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="1_4" id="1_4">
                    <label for="1_4">1.4 Поиск: querySelector*</label>
                    <p class="for-what">Зачем? Испоьзуется постоянно в чистом JS, например чтобы получить элемент кнопки и добавить на него слушателя.</p>
                    <ul>
                        <li class="green">elem.querySelector/querySelecorAll("css-rule"): возвращает первый/все элементы, соотв. css-rule (с # для id, . для class) </li>
                        <li class="blue">elem.closest("css-rule"): возвращает ближайшего предка, который подходит под css-rule</li>
                        <li class="blue">elem1.contains(elem2): возвращает true если elem1 содержит внутри себя elem2 или если elem1 === elem2</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="1_5" id="1_5">
                    <label for="1_5">1.5 Свойства узлов: тип, тег и содержимое</label>
                    <p class="for-what">Зачем? Для более подробного понимания того, что происходит в браузере, как реагирует браузер на написанный код.</p>
                    <ul>
                        <li class="green">DOM-узлы принадлежат соответствующим встроенным классам: EventTarget(events)/Node(узлы)/Element(методы)/HTMLElement</li>
                        <li class="blue">EventTarget: это корневой класс, его объекты никогда не создаются, но он нужен для поддержи событий в браузере</li>
                        <li class="green">elem.innerHTML: возвращает HTML-содержимое элемента, ему можно присваивать значение, строкой. el.innerHTML = "NEW"</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="1_6" id="1_6">
                    <label for="1_6">1.6 Атрибуты и свойства</label>
                    <p class="for-what">Зачем? Не уверен, что это применимо на практике, просто чтобы понимать разницу между HTML-атрибутами и DOM-свойствами.</p>
                    <ul>
                        <li class="green">HTML-атрибуты: это атрибуты внутри тегов HTML, когда браузер парсит HTML, он создаёт DOM-свойства для этих атрибутов</li>
                        <li class="green">DOM-свойства: у DOM элементов (например input) есть поля (например title), мы можем их задать: $el = {title: "Gregory"}</li>
                        <li class="blue">Нестандартные атрибуты, dataset: нужные для стилизации или идентификации. Синтаксис: div data-about="About">>div</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="1_7" id="1_7">
                    <label for="1_7">1.7 Изменение документа</label>
                    <p class="for-what">Зачем? Очень распространённый механизм, который сейчас инкапсулирован в фреймворки, для понимания того как оно работает.</p>
                    <ul>
                        <li class="green">Создание элемента: document.createElement(tag // с заданным тегом), document.createTextNode(text // с заданым текстом)</li>
                        <li class="green">Вставка элемента: document.el1.append/prepend(el2), вставляющий el2 в el1 в конец/начало родительского узла</li>
                        <li class="green">el.insertAdjacentHTML(where, html): where принимает строковые значения (гугл), html это html который мы хотим вставить</li>
                        <li class="green">Удаление элемета: el.remove() просто удаляет элемент, всё</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="1_8" id="1_8">
                    <label for="1_8">1.8 Стили и классы</label>
                    <p class="for-what">Зачем? Редкие случаи, когда по какому-то логическому условию нужно добавить или изменить стили у элемента.</p>
                    <ul>
                        <li class="green">Задание стилей через style: можно добавить стили через stye. Пример: let left = ...; elem.style.left = left;</li>
                        <li class="blue">className: раньше слово "class" имело ограничение и его поле назвали className. Пример: el.className;</li>
                        <li class="green">classList: возвращаем массив классов элемента, его длину и класс родителя. Синтаксис: el.classList;</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="1_9" id="1_9">
                    <label for="1_9">1.9 Размеры и прокрутка элементов</label>
                    <p class="for-what">Зачем? Не уверен, что это может пригодиться часто, возможно для изменения размеров элементов внутри JavaScript.</p>
                    <ul>
                        <li class="violet">Внешние метрики: block.offsetLeft/offsetTop (отступы элемента отсносит. родителя), block.offestParent (родительский элемент)</li>
                        <li class="violet">Общие размеры: block.offsetWidth/offsetHeight (padding + border + width/height)</li>
                        <li class="violet">Свойства scrollWidth/scrollHeight: возвращает ширину/высоту контента, на который можно делать скролл</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="1_10" id="1_10">
                    <label for="1_10">1.10 Размеры и прокрутка окна</label>
                    <p class="for-what">Зачем? Может понадобиться например на landing page, когда при нажатии на кнопку меню надо прокрутить страницу до элемента.</p>
                    <ul>
                        <li class="violet">Ширина и высота окна браузера: document.documentElement.clientWidth/clientHeight (ширина/высота видимого контента)</li>
                        <li class="violet">Ширина и высота окна браузера (с полосой прокрутки): window.innerWidth/innerHeight (ширина/высота контента со скроллом)</li>
                        <li class="violet">Кол-во прокрученных пикселей: window.pageYOffset (высота), window.pageXOffset (ширина)</li>
                        <li class="blue">Метод window.scrollBy/scrollTo(x, y): прокрутит страницу на/до x или y пикселей, можно запускать по условию</li>
                        <li class="blue">Метод elem.scrollIntoView(true/false): прокрутит страницу до верха elem (если true) или до низа elem (если false)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="1_11" id="1_11">
                    <label for="1_11">1.11 Координаты</label>
                    <p class="for-what">Зачем? Есть две системы координат: относительно окна браузера (clientX/Y), и относительно документа (pageX/pageY).</p>
                    <ul>
                        <li class="violet">Метод elem.getBoundingClientRect(): получение координат elem относительно окна браузера</li>
                        <li class="blue">Как получить высоту относительно документа: elem.getBoundingClientRect().top + window.pageYOffest</li>
                    </ul>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>2) Введение в события</b><hr>
                <div>
                    <input type="checkbox" name="2_1" id="2_1">
                    <label for="2_1">2.1 Браузерное окружение, спецификации</label>
                    <p class="for-what">Зачем? Это основа взаимодействий JavaScript с DOM элементами и динамикой любых сайтов.</p>
                    <ul>
                        <li class="blue">События мыши: click/contextmenu (клик ЛКМ/ПКМ), mouseover/out (навод./покид.), mousedown/over (нажать/отпустить), mousemove</li>
                        <li class="green">События на формах: submit (отправка формы form), focus (фокусировка на элемента управления, напр. input)</li>
                        <li class="green">События клавиатуры: keydown (нажимает на клавишу), keyup (отпускает клавишу)</li>
                        <li class="blue">События документа: DOMContentLoaded (когда HTML загружен и обработан, DOM полностью построен и доступен)</li>
                        <li class="green">События CSS: transitioned (когда CSS анимация завершена)</li>
                        <li class="blue">Обработчики событий: elem.addEventListener("event", callback) позволяет обработать элемент на нужное событие</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_2" id="2_2">
                    <label for="2_2">2.2 Всплытие и погружение</label>
                    <p class="for-what">Зачем? Это основа вообще всего, сверхзнание, доступное всем, но изученное не всеми.</p>
                    <ul>
                        <li class="blue">Всплытие: когда на элементе происходит событие, обработчики срабатывают на нём, а срабатывает вверх по цепочке предков</li>
                        <li class="green">Целевой элемент: это элемент который вызывает событие, он доступен через event.target</li>
                        <li class="blue">Как прекратить всплытие? Вызвать метод event.stopPropagation() в том месте, где нужно остановить событие</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_3" id="2_3">
                    <label for="2_3">2.3 Делегирование событий</label>
                    <p class="for-what">Зачем? Не нужно вешать много обработчиков.</p>
                    <ul>
                        <li class="green">Делегирование: есть много элементов, вместо обработчика на каждого, ставим общий обработчик на родителя</li>
                        <li class="blue">Алгоритм: вешаем обработчик на контейнер -> в обработчике проверяем event.target -> обрабатываем событие нужных элементов</li>
                        <li class="blue">Ограничения: событие должно всплывать, не должно быть event.stopPropagation(), создаёт дополнительную нагрузку на браузер</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_4" id="2_4">
                    <label for="2_4">2.4 Действия браузера по умолчанию</label>
                    <p class="for-what">Зачем? Событие по умолчанию может перекрывать кастомное событие, что нам не нужно.</p>
                    <ul>
                        <li class="green">Действия браузера по умолчанию, что это? Такие события, как клик по ссылке и переход на страницу, выделение текста</li>
                        <li class="blue">Отмена действия по умолчанию: воспользоваться объектом event и вызвать event.preventDefault()</li>
                    </ul>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>3) Интерфейсные события</b><hr>
                <div>
                    <input type="checkbox" name="3_1" id="3_1">
                    <label for="3_1">3.1 Основы событий мыши</label>
                    <p class="for-what">Зачем? Может пригодиться для кастомных меню на ПКМ, или отмены выделения текста при двойном нажатии.</p>
                    <ul>
                        <li class="green">Дополнительные события мыши: dbclick (срабатывает на двойной клик по элементу)</li>
                        <li class="green">Получение информации о кнопке: event.which === 1 (ЛКМ), === 2 (СКМ), === 3 (ПКМ)</li>
                        <li class="blue">Отключаем выделение: текст при двойном клике выделяется, фикс это сделать onmousedown="return false"</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="3_2" id="3_2">
                    <label for="3_2">3.2 Движение мыши: mouseover/out, mouseenter/leave</label>
                    <p class="for-what">Зачем? Это основа красивых кастомизаций наведения, в общем полезно для стиля.</p>
                    <ul>
                        <li class="green">Событие mouseover: когда курсор над элементом, где event.target (эл. куда перешёл), event.relatedTarget (эл. откуда ушёл)</li>
                        <li class="green">Событие mouseout: когда курсор уходит с элемента, где event.target (эл. откуда ушёл), event.relatedTarget (эл. куда перешёл)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="3_3" id="3_3">
                    <label for="3_3">3.3 Drag'n'Drop с событиями мыши</label>
                    <p class="for-what">Зачем? Есть некоторый список задач, который требует Drag n Drop, например kanban доска.</p>
                    <ul>
                        <li class="blue">Важно понимать: есть три основные сущности при перетаскивании элемента (draggableElement, zoneFrom, zoneTo)</li>
                        <li class="violet">Алгоритм (этап 1): задать элементу пропсу draggable="true", чтобы элемент можно было перетаскивать</li>
                        <li class="violet">Алгоритм (этап 2): задать zoneTo.ondragover функцию с evt.preventDefault(), чтобы отменить стандартное поведение браузера</li>
                        <li class="violet">Алгоритм (этап 3): задать draggableElement.ondragstart функцию с evt.dataTransfer.setData("prop", evt.target.prop)</li>
                        <li class="violet">Алгоритм (этап 4): задать zoneTo.ondrop функцию с evt.dataTransfer.getData("prop") и evt.target.append(идентификатор)</li>
                        <li class="violet">Алгоритм (этап 5+): добавляем оставшийся функционал (тени, перенос обратно и так далее)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="3_4" id="3_4">
                    <label for="3_4">3.4 Клавиатура: keydown и keyup</label>
                    <p class="for-what">Зачем? Применяется не так часто, но самый распространённый пример это нажатие кнопки через нажатие клавиши Enter.</p>
                    <ul>
                        <li class="green">События keydown (при нажатии клавиши) и keyup (при отпускании клавиши): document.addEventListener('keydown', callback)</li>
                        <li class="blue">Надёжнее использовать не event.code, а event.key (это связано с разными клавиатурами в разных странах)</li>
                        <li class="blue">Действия по умолчанию: например на Ctrl + S, чтобы их предотвратить (и написать свою логику) использует e.preventDefault()</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="3_5" id="3_5">
                    <label for="3_5">3.5 События указателя</label>
                    <p class="for-what">Зачем? Это как события мыши, но ещё и точпада, пера и прочего, а ещё упрощает Drag n Drop ползунка.</p>
                    <ul>
                        <li class="green">Названия почти такие же как у mouse событий: mousedown -> pointerdown итд, вместо mouse можно писать pointer всегда</li>
                        <li class="green">Drag n Drop (этап 1): el.onpointerdown функция el.setPointerCapture(evt.pointerId);</li>
                        <li class="green">Drag n Drop (этап 2): el.onpointermove функция el.style.left = (evt.clientX - slider.getBoundingClientRect().left) + "px"</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="3_6" id="3_6">
                    <label for="3_6">3.6 Прокрутка</label>
                    <p class="for-what">Зачем? Показать что-то на определённом этапе, сделать кнопку для прокрутки в начало, сделать кнопку agree terms активной.</p>
                    <ul>
                        <li class="green">Синтаксис: window.addEventListener('scroll', function)</li>
                        <li class="blue">Подгрузить данные: const loadMore = () => if (doc.docEl.getBoundClRect().bottom &lt; doc.docEl.cliHeight + 100) {loadMore()}</li>
                        <li class="blue">Пролистать вверх: arrowTop.onclick = () => window.scrollTo(pageXOffset, 0);</li>
                    </ul>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>4) Формы, элементы управления</b><hr>
                <div>
                    <input type="checkbox" name="4_1" id="4_1">
                    <label for="4_1">4.1 Свойства и методы формы</label>
                    <p class="for-what">Зачем? Кратко: через DOM можно достучаться до элементов формы, но сейчас много фреймворков и либ, поэтому это не так важно.</p>
                    <ul>
                        <li class="green">Как достучаться до формы? document.forms.my (my это пропса у формы, name="my") или document.forms[0] (вариант хуже)</li>
                        <li class="green">Как достучаться до элемента формы? document.forms.my.elements.age (age это пропса у формы, name="age")</li>
                        <li class="blue">Элементы формы (input и textarea): значение можно получить через input.value/textarea.value/checkbox.checked</li>
                        <li class="blue">Элементы формы (select и option): select.options (DOM тега option), select.value/selectedIndex (value выбранного option/id)</li>
                        <li class="green">Создание элемента option: option = new Option(text, value, defaultSelected, selected);</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="4_2" id="4_2">
                    <label for="4_2">4.2 Фокусировка: focus/blur</label>
                    <p class="for-what">Зачем? На фокусировке можно добавить всплывающую подсказку, а размытие может случаться при отправке данных.</p>
                    <ul>
                        <li class="green">События focus/blur: можно обработать событие. Пример: input.onblur = function(), input.onfocus = function()</li>
                        <li class="green">Выбор порядка фокусировки (tabIndex): задаём элементам пропсу tabIndex="0..n" и на tab будет порядок сортировки</li>
                        <li class="blue">События focusin/focusout: события focus/blur не всплывают, а если нужно всплытие то используют focusin/focusout</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="4_3" id="4_3">
                    <label for="4_3">4.3 События: change, input, cut, copy, paste</label>
                    <p class="for-what">Зачем? Реакция на нажатие кнопок, на ввод данных, и так далее, сейчас есть множество библиотек которые это делают за нас.</p>
                    <ul>
                        <li class="green">Событие onchange: пропса onchange на input (когда сменим focus), на select (когда выберем option)</li>
                        <li class="green">Событие oninput: пропса oninput на input (когда меняем значение в input), подходит для regexp</li>
                        <li class="green">События cut, copy, paste: пропса oncut/oncopy/onpaste на input (когда вырезаем/копируем/вставляем)</li>
                        <li class="blue">Предотвращение cut/copy/paste: можно предотвратить с помощью event.clipboardData() или event.preventDefault()</li>
                    </ul>
                </div>
            </div>
        </section>
    </div>
    <script>
        const showReds = document.querySelector("#show_reds");
        const hideReds = document.querySelector("#hide_reds");
        const reds = document.querySelectorAll('.hidden');
        showReds.addEventListener('click', () => reds.forEach(red => red.tagName === "LI"? red.style.display = 'list-item' : red.style.display = 'block'));
        hideReds.addEventListener('click', () => reds.forEach(red => red.style.display = 'none'));

        const hideForWhat = document.querySelector("#hide_for_what");
        const forWhat = document.querySelectorAll(".for-what");
        hideForWhat.addEventListener('click', () => forWhat.forEach(el => el.style.display = 'none'));

        const hidePractise = document.querySelector("#hide_practise");
        const practise = document.querySelectorAll(".helpful");
        hidePractise.addEventListener('click', () => practise.forEach(el => el.style.display = 'none'));
    </script>
</body>
</html>