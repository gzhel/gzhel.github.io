<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css">
    <link rel="stylesheet" href="../../styles.css">
    <title>Типы данных</title>
</head>
<body>
    <div class="learn-page__layout">
        <h1><a href="../../1_module/">Back to module 1</a></h1>
        <section class="learn-page__layout--study-block">
            <h3>Обозначения:</h3>
            <div class="text checked">Зеленый блок = прогресс изучения; Зеленая рамка = повторил, классно.</div>
            <div class="help helpful">Синий блок = полезная подсказка; Синяя рамка = очень важно, очень классно.</div>
            <div class="script useless">Красный блок = задача; Красная рамка = на мой взгляд не стоит внимания.</div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>5.1 Методы у примитивов</h3>
            <div class="text">
                <b>Основы</b>
                <p>
                    JavaScript позволяет нам работать с примитивными типами данных (строками, числами и т.д.), будто они являются объектами. У них есть и методы. <br>
                    Есть 7 примитивных типов: string, number, boolean, symbol, null, undefined и bigint. И ещё есть объект, он не примитив.
                </p>
            </div>
            <div class="text">
                <b>Примитив как объект</b>
                <p>
                    Примитивы остаются примитивами. Одно значение, как и хотелось. <br></br>
                    Язык позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов. <br></br>
                    Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется. <br></br>
                    Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean и Symbol. <br><br>
                    null/undefined не имеют методов.
                </p>
            </div>
            <div class="script">
                <b>Задачи. Можно ли добавить свойство строке?</b>
                <p>
                    <code>
                        Нет, нельзя. Примитивы это не объекты, мы можем лишь вызывать методы их "оберток".
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>5.2 Числа (number)</h3>
            <div class="help">
                <b>Способы записи числа</b>
                <p>
                    1) let billion = 1e9; // 1 и 9 нулей <br><br>
                    2) let ms = 1e-6; // шесть нулей, слева от 1 <br><br>
                    3) alert( 0xFF ); // 255 (шестнадцатиричные) <br><br>
                    4) let b = 0o377; // восьмеричная форма записи числа 255 <br><br>
                    4) let a = 0b11111111; // бинарная форма записи числа 255
                </p>
            </div>
            <div class="text">
                <b>toString(base)</b>
                <p>
                    num.toString(base) возвращает строковое представление числа num в системе счисления base. <br><br>
                    Например: let num = 255; alert( num.toString(16) );  // ff<br><br>
                    Две точки для вызова метода: если нам надо вызвать метод на числе, то нужно поставить две точки (123456..toString(36))
                </p>
            </div>
            <div class="text">
                <b>Округление</b>
                <p>
                    В JavaScript есть несколько встроенных функций для работы с округлением: <br><br>
                    1) Math.floor: Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.<br><br>
                    2) Math.ceil: Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.<br><br>
                    3) Math.round: Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.<br><br>
                    4) Math.trunc: Удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.<br><br>
                    Метод toFixed(n) округляет число до n знаков после запятой и возвращает строку. <br><br>
                </p>
            </div>
            <div class="text">
                <b>Неточные вычисления</b>
                <p>
                    Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт Infinity <br><br>
                    Наиболее часто встречающаяся ошибка при работе с числами в JavaScript – это потеря точности: <br></br>
                    Это работает так: alert( 0.1 + 0.2 ); // 0.30000000000000004 <br><br>
                    Почему так? Дроби являются бесконечной дробью в двоичной форме. <br><br>
                    Что такое 0.1? Это единица делённая на десять — 1/10, одна десятая. 
                    В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: 1/3, 
                    которая становится бесконечной дробью 0.33333(3). <br></br>
                    В JavaScript нет возможности для хранения точных значений 0.1 или 0.2, используя двоичную систему, 
                    точно также, как нет возможности хранить одну третью в десятичной системе счисления. <br><br>
                    Как решить проблему? Использовать +number.toFixed(n)
                </p>
            </div>
            <div class="help">
                <b>Проверка: isFinite и isNaN</b>
                <p>
                    isNaN(value) преобразует значение в число и проверяет является ли оно NaN <br><br>
                    isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity <br></br>
                    Помните, что пустая строка интерпретируется как 0 во всех числовых функциях, включаяisFinite.
                </p>
            </div>
            <div class="text">
                <b>parseInt и parseFloat</b>
                <p>
                    Для явного преобразования к числу можно использовать + или Number(). 
                    Если строка не является в точности числом, то результат будет NaN.
                    Единственное исключение — это пробелы в начале строки и в конце, они игнорируются. <br><br>
                    Для этого есть parseInt и parseFloat. Они «читают» число из строки. parseInt('100px') // 100
                </p>
            </div>
            <div class="help">
                <b>Другие математические функции</b>
                <p>
                    1) Math.random(): Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1).<br><br>
                    2) Math.max(a, b, c...) / Math.min(a, b, c...): Возвращает наибольшее/наименьшее число из перечисленных аргументов.<br><br>
                    3) Math.pow(n, power): Возвращает число n, возведённое в степень power.
                </p>
            </div>
            <div class="script">
                <b>Задачи. Сумма пользовательских чисел</b>
                <p>
                    <code>
                        let a = +prompt("A:", 0);
                        let b = +prompt("B:", 0);
                        alert(a + b);
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Почему 6.35.toFixed(1) == 6.3?</b>
                <p>
                    <code>
                        alert(Math.round(6.35 * 10) / 10); // 6.35 имеет потерю точности (прочитал позже), round округляет в большую сторону
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Ввод числового значения</b>
                <p>
                    <code>
                        function readNumber() {
                            let num;
                            for (;!isFinite(num);) {
                                num = prompt("Число:", "");
                                if (num === null || num === "") {
                                    return null;
                                }
                            }
                            return +num;
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Бесконечный цикл по ошибке</b>
                <p>
                    <code>
                        0.2 имеет потерю точности, и никогда не достигнет 10
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Случайное число от min до max</b>
                <p>
                    <code>
                        function random(min, max) {
                            return min + Math.random() * (max - min);
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Случайное целое число от min до max</b>
                <p>
                    <code>
                        function randomInteger(min, max) {
                            return Math.floor(min + Math.random() * (max + 1 - min));
                        }
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>5.3 Строки (string)</h3>
            <div class="text">
                <b>Кавычки</b>
                <p>
                    Строку можно создать с помощью одинарных, двойных либо обратных кавычек.
                </p>
            </div>
            <div class="text">
                <b>Спецсимволы</b>
                <p>
                    Список спецсимволов:
                </p>
                <img src="./img/1.png" alt="" width="100%">
            </div>
            <div class="text">
                <b>Длина строки</b>
                <p>
                    Свойство length содержит длину строки: alert( `My\n`.length ); // 3
                </p>
            </div>
            <div class="text">
                <b>Доступ к символам</b>
                <p>
                    Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: [pos]. <br><br>
                    Также можно использовать метод charAt: str.charAt(pos). <br><br>
                    Разница только в том, что если символ с несуществующей позицией отсутствует, тогда [] вернёт undefined, а charAt — пустую строку. <br><br>
                    Пример: let str = `Hello`; alert( str[str.length - 1] ); // o
                </p>
            </div>
            <div class="text">
                <b>Строки неизменяемы</b>
                <p>
                    Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. 
                    Как только строка создана — она такая навсегда.<br><br>
                    Пример: let str = 'Hi'; str[0] = 'h'; // ошибка
                </p>
            </div>
            <div class="text">
                <b>Изменение регистра</b>
                <p>
                    Методы toLowerCase() и toUpperCase() меняют регистр символов.
                </p>
            </div>
            <div class="text">
                <b>Поиск подстроки (str.indexOf)</b>
                <p>
                    Первый метод — str.indexOf(substr, pos). Он ищет подстроку substr в строке str, 
                    начиная с позиции pos, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений. <br></br>
                    Пример: let str = 'Widget with id'; alert( str.indexOf('id', 2) ) // 12
                </p>
            </div>
            <div class="text">
                <b>Поиск подстроки (includes, startsWith, endsWith)</b>
                <p>
                    Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет. <br><br>
                    Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна. <br><br>
                    alert( "Widget with id".includes("Widget") ); // true <br><br>
                    alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget" <br><br>
                    alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"
                </p>
            </div>
            <div class="help">
                <b>Получение подстроки</b>
                <p>
                    В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.<br><br>
                    1) str.slice(start [, end]): возвращает от start до end (не включая end).
                    Числа с минусом означают позицию справа, а не слева.<br><br>
                    Пример: let str = "stringify"; alert( str.slice(0, 5) ); // 'strin', символы от 0 до 5 (не включая 5). <br><br>
                    2) str.substring(start [, end]): возвращает часть строки между start и end. <br><br>
                    Отрицательные значения равнозначны 0. <br><br>
                    let str = "stringify"; alert( str.substring(2, 6) ); // "ring"; alert( str.substring(6, 2) ); // "ring" <br><br>
                    3) str.substr(start [, length]): возвращает часть строки от start длины length. <br><br>
                    Значение start может быть отрицательным. <br><br>
                    Пример: let str = "stringify"; alert( str.substr(2, 4) ); // ring, получаем 4 символа, начиная с позиции 2 <br><br>
                    <p class="helpful">Из этих методов slice наиболее гибок и лучше выбирать его.</p> 
                </p>
            </div>
            <div class="text">
                <b>Дополнительно про строки</b>
                <p>
                    Строки также имеют ещё кое-какие полезные методы: <br><br>
                    1) str.trim() — убирает пробелы в начале и конце строки. <br><br>
                    2) str.repeat(n) — повторяет строку n раз.
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>5.4 Массивы</h3>
            <div class="text">
                <b>Объявление</b>
                <p>
                    Два варианта синтаксиса для создания пустого массива: let arr = new Array(); let arr = []; <br><br>
                    Почти всегда используется второй. <br><br>
                    Элементы массива нумеруются, начиная с нуля. <br><br>
                    Получить элемент: let fruits = ["Яблоко", "Апельсин", "Слива"]; fruits[0]; alert( fruits[0] ); // Яблоко <br><br>
                    Заменить элемент: fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"] <br><br>
                    Добавить новый к существующему массиву: fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"] <br><br>
                    Общее число элементов массива содержится в его свойстве length: fruits.length<br><br>
                    В массиве могут храниться элементы любого типа: [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ]
                </p>
            </div>
            <div class="text">
                <b>Методы pop/push, shift/unshift</b>
                <p>
                    Есть два подхода к пониманию данных в массиве: очередь и стек. <br><br>
                    Очередь: push добавляет элемент в конец. shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым. <br></br>
                    Когда использовать очередь? Например, очередь сообщений, которые надо показать на экране. <br></br>
                    Стек: push добавляет элемент в конец. pop удаляет последний элемент. <br></br>
                    Когда использовать стек? Колода карт: новые карты кладутся наверх и берутся тоже сверху. <br></br>
                    Методы push и unshift могут добавлять сразу несколько элементов (указанных в скобках).
                </p>
            </div>
            <div class="help">
                <b>Методы, работающие с концом массива</b>
                <p>
                    1) pop: Удаляет последний элемент из массива и возвращает его. <br></br>
                    Пример: let fruits = ["Яблоко", "Апельсин", "Груша"];  <br></br>
                    alert( fruits.pop() ); // удаляем "Груша" и выводим его  <br></br>
                    alert( fruits ); // Яблоко, Апельсин <br></br>
                    2) push: Добавляет элемент в конец массива. <br></br>
                    Пример: let fruits = ["Яблоко", "Апельсин"]; <br><br>
                    fruits.push("Груша"); <br><br>
                    alert( fruits ); // Яблоко, Апельсин, Груша
                </p>
            </div>
            <div class="help">
                <b>Методы, работающие с началом массива</b>
                <p>
                    1) shift: Удаляет из массива первый элемент и возвращает его. <br></br>
                    Пример: let fruits = ["Яблоко", "Апельсин", "Груша"];  <br></br>
                    alert( fruits.shift() ); // удаляем Яблоко и выводим его  <br></br>
                    alert( fruits ); // Апельсин, Груша <br></br>
                    2) unshift: Добавляет элемент в начало массива. <br></br>
                    Пример: let fruits = ["Апельсин", "Груша"]; <br><br>
                    fruits.unshift('Яблоко'); <br><br>
                    alert( fruits ); // Яблоко, Апельсин, Груша
                </p>
            </div>
            <div class="text">
                <b>Внутреннее устройство массива</b>
                <p>
                    Квадратные скобки, используемые для того, чтобы получить доступ к свойству arr[0] – это по сути обычный синтаксис доступа по ключу, 
                    как obj[key], где в роли obj у нас arr, а в качестве ключа – числовой индекс. <br><br>
                    Массив является объектом и, следовательно, ведёт себя как объект. (typeof [] // "object")<br></br>
                    Массив копируется по ссылке: let fruits = ["Банан"]; let arr = fruits; // копируется по ссылке <br><br>
                    Массив следует считать особой структурой, позволяющей работать с упорядоченными данными. Для других целей стоит использовать объект.
                </p>
            </div>
            <div class="help">
                <b>Эффективность</b>
                <p>
                    Методы push/pop выполняются быстро, а методы shift/unshift – медленно.
                </p>
            </div>
            <div class="text">
                <b>Перебор элементов</b>
                <p>
                    Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам: 
                    for (let i = 0; i &lt; arr.length; i++) {...} <br><br>
                    Возможен и другой вариант цикла, for..of: for (let fruit of fruits) {...} <br><br>
                </p>
            </div>
            <div class="text">
                <b>Немного о «length»</b>
                <p>
                    Свойство length автоматически обновляется при изменении массива. 
                    Если быть точными, это не количество элементов массива, а наибольший цифровой индекс плюс один. <br></br>
                    length можно перезаписать. Таким образом, самый простой способ очистить массив – это arr.length = 0;.
                </p>
            </div>
            <div class="text">
                <b>Многомерные массивы</b>
                <p>
                    Массивы могут содержать элементы, которые тоже являются массивами. 
                    Это можно использовать для создания многомерных массивов, например, для хранения матриц: <br><br>
                    let matrix = [[1, 2, 3],[4, 5, 6],[7, 8, 9]]; alert( matrix[1][1] ); // 5, центральный элемент
                </p>
            </div>
            <div class="text">
                <b>toString</b>
                <p>
                    Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми. <br><br>
                    Массивы реализуют только преобразование toString, таким образом, здесь [] становится пустой строкой, а [1,2] становится "1,2".
                </p>
            </div>
            <div class="script">
                <b>Задачи. Скопирован ли массив?</b>
                <p>
                    <code>
                        4 (0..3 + 1). Т.к. массивы это те же объекты и тут shoppingCart и fruits это ссылки на один массив.
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Операции с массивами</b>
                <p>
                    <code>
                        let styles = ["Джаз", "Блюз"];
                        styles.push("Рок-н-ролл");
                        styles[Math.floor((styles.length - 1) / 2)] = "Классика";
                        alert(styles.shift());
                        styles.unshift("Рэп", "Регги");
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Вызов в контексте массива</b>
                <p>
                    <code>
                        Расшифрую немного: <br><br>
                        let arr = ["a", "b"]; <br><br>
                        arr.push(function() {alert(this);}); // ["a", "b", function] <br><br>
                        arr[2](); // function() <br><br>
                        Вернёт контекст arr: ["a", "b", function]
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Сумма введённых чисел</b>
                <p>
                    <code>
                        function sumInput() {
                            let nums = [];
                            while (true) {
                                let num = +prompt("Input number:", 0);
                                nums.push(num);
                                if (num === "" || num === null || !isFinite(num)) {
                                    break;
                                }
                            }
                            let sum = 0;
                            for (let number of numbers) {
                                sum += number;
                            }
                            return sum;
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Подмассив наибольшей суммы</b>
                <p>
                    <code>
                        no way
                    </code>
                </p>
            </div>
        </section>
    </div>
</body>
</html>