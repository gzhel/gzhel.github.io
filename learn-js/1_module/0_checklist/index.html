<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../styles.css">
    <title>Checklist 2.0</title>
</head>
<body>
    <div class="learn-page__layout checklist">
        <h1><a href="../../1_module/" style="color: red;">Back to module 1</a></h1>
        <section class="learn-page__layout--study-block">
            <h3>Обозначения (субъективно):</h3>
            <div style="margin-bottom: 6px;"><span class="blue">Синий</span>: актуально, не очевидно, secret knowledge</div>
            <div><span class="green">Зеленый</span>: актуально, стоит изучать внимательно</div>
            <div>
                <span style="color: red">Красный</span>: допустимо, в 99% случаев не используется 
                <span><button id="show_reds">Показать "красные" пункты</button></span>
                <span><button id="hide_reds">Скрыть "красные" пункты</button></span>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>2) Основы JavaScript <a href="https://jsfiddle.net/gzhel/o1hn3bg6/127/" target="_blank">(примеры кода)</a></b><hr>
                <div style="display: none;">
                    <input type="checkbox" name="2_2" id="2_2" checked>
                    <label for="2_2">2.2 Структура кода</label>
                    <p class="for-what">Зачем? Для обозначения окончания выражений, описания принятых решений.</p>
                    <ul>
                        <li class="green">Точка с запятой в конце выражения</li>
                        <li class="green">Комментарии</li>
                    </ul>
                    <p class="green">1) Точка с запятой в конце выражения </p>
                    <p class="green">2) Комментарии</p>
                </div>
                <div>
                    <input type="checkbox" name="2_3" id="2_3" checked>
                    <label for="2_3">2.3 Строгий режим - "use strict"</label>
                    <p class="for-what">Зачем? Для работы с легаси проектами, но вообще сейчас 99% это модульные проекты, а модули автоматически добавляют "use strict".</p>
                    <ul>
                        <li class="green">"use strict": данная строка позволяет работать старыми возможностями языка, убранными с ES6+</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_4" id="2_4" checked>
                    <label for="2_4">2.4 Переменные</label>
                    <p class="for-what">Зачем? Практически всё в JS построенно на переменных, они служат хранилищем данных для любых структур данных.</p>
                    <ul>
                        <li class="green">let: переменная, можно переопределять, имеет блочную {} область видимости</li>
                        <li class="green">const: константа, нельзя переопределять, имеет блочную {} область видимости</li>
                        <li class="red">var: переменная (устаревшее), имеет область видимости файла/функции, но не блока</li>
                        <li class="green">Именование: camelCase, должны быть ясны, конкретика, но не более 2-3 слов, например: userName</li>
                        <li class="blue">Можно присвоить результат выполнения функции переменной, например: let result = sum(2, 3) // 5</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_5" id="2_5" checked>
                    <label for="2_5">2.5 Типы данных</label>
                    <p class="for-what">Зачем? Разные типы данных имеют разные методы. Работа с "примитивами" отличается от работы с "объектами" (и массивами).</p>
                    <ul>
                        <li class="green">Есть 8 типов данных: number, string, object, bool, null, undefined, BigInt (big number), Symbol</li>
                        <li class="blue">Примитивы (все типы кроме object) равны сами себе. Например: 1 === 1 // true</li>
                        <li class="blue">Объекты (и массивы, т.к. это объект) не равны сами себе. Наример: {id: 1} === {id: 1} // false</li>
                        <li class="blue">Уникальность объектов может вызвать проблему при поиске "уникального" объекта в массиве. Для этого используют filter + some</li>
                        <li class="green">Оператор typeof возвращает тип чего-либо строкой. Например: typeof 1; // "number"</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_7" id="2_7" checked>
                    <label for="2_7">2.7 Преобразование типов</label>
                    <p class="for-what">Зачем? Например, часто можем получать результат инпута типом string, бекенд ждёт number, нужно делать преобразование типов.</p>
                    <ul>
                        <li class="green">Строковое преобразование к типу string: String(value) или value + ""</li>
                        <li class="green">Численное преобразование к типу number: Number(value) или +value</li>
                        <li class="green">Логическое преобразование к типу bool: Boolean(value) или !!value</li>
                        <li class="blue">0, null, undefined, NaN, "" возвращает false, всё остальное возвращает true. Например: [], {} вернёт true</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_8" id="2_8" checked>
                    <label for="2_8">2.8 Базовые операторы, математика</label>
                    <p class="for-what">Зачем? Самый простой пример это итераторы, к примеру цикл for, который сейчас устаревает, в основном это просто часть истории.</p>
                    <ul>
                        <li class="red">«унарный» (+a), «бинарный» (a + b), «операнд» (a, b - это операнды)</li>
                        <li class="green">Постфиксный инкремент (v++)/декремент (v--), увеличить, но получить результат до увеличения</li>
                        <li class="green">Префиксный инкремент (++v)/декремент (--v), увеличить, и сразу получить новый результат</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_9" id="2_9" checked>
                    <label for="2_9">2.9 Операторы сравнения</label>
                    <p class="for-what">Зачем? Сравнение используется очень часто, в тех же тернарных операторах, условиях, везде, это одна из важнейших вещей.</p>
                    <ul>
                        <li class="green">Результат сравнения имеет логический тип: let a = 3 > 2; // true</li>
                        <li class="green">Всегда стоит использовать строгое сравнение (===, !==), оно проверяет не только на значение, но и на тип данных</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_10" id="2_10" checked>
                    <label for="2_10">2.10 Условное ветвление: if, '?'</label>
                    <p class="for-what">Зачем? Довольно распространено в комбинации с return, если А, то верни А1, если Б, то верни Б1 и так далее.</p>
                    <ul>
                        <li class="green">if (condition) {...}, к нему опционально идёт: else if (condition) {...} else {...}</li>
                        <li class="green">Тернарный оператор "?". Пример: let result = условие ? значение1 : значение2;</li>
                        <li class="blue">Часто в функциях используют if (condition) {return ...}, это позволяет выйти из функции и вернуть значение по условию</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_11" id="2_11" checked>
                    <label for="2_11">2.11 Логические операторы</label>
                    <p class="for-what">Зачем? Часто используются для присвоения булевых значений переменным, либо для рендера компонентов если цепочка условий true.</p>
                    <ul>
                        <li class="green">ИЛИ «||» находит первое значение равное true, либо возвращает последнее значение в цепочке. Пример: 0 || 1 || 2 // 1</li>
                        <li class="green">И «&&» находит первое значение равное false, либо возвращает последнее значение в цепочке. Пример: 1 && 0 && 2 // 0</li>
                        <li class="green">НЕ «!» приводит аргумент к bool, возвращает противоположное значение. Пример: !1 // false</li>
                        <li class="red">Объединение с null '??': возвращает первое определённое значение (в отлчие от || различает false, 0, "" и null/undefined)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_13" id="2_13" checked>
                    <label for="2_13">2.13 Циклы while и for</label>
                    <p class="for-what">Зачем? Уже буквально все циклы можно считать устаревшими, вместо них используют перебирающие методы, просто часть истории.</p>
                    <ul>
                        <li class="red">Цикл «while»: while (condition) {...}, цикл выполняется, пока условие condition истинно</li>
                        <li class="red">Цикл «do...while»: выполнит тело, а затем проверит условие condition, и пока его значение равно true</li>
                        <li class="red">Цикл «for»: for (начало; условие; шаг) {тело}, послед.: начало => (условие -> тело -> шаг -> условие)}</li>
                        <li class="red">Прерывание цикла «break»: позволяет выйти из цикла, if (!value) {break;}</li>
                        <li class="blue">Обычные циклы устарели, используйте перебираемые методы (map, filter, forEach и так далее)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_14" id="2_14" checked>
                    <label for="2_14">2.14 Конструкция "switch"</label>
                    <p class="for-what">Зачем? Исходя из моего опыта, могу сказать, что всегда используется в redux редьюсерах, вероятно используется где-то ещё.</p>
                    <ul>
                        <li class="green">switch(x) {case 'val1': ... break; default: ... break;}, проверка строгая (===), case могут быть слитно (на 2 case 1 действие)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_15" id="2_15" checked>
                    <label for="2_15">2.15 Функции</label>
                    <p class="for-what">Зачем? Исходя из моего опыта, могу сказать, что всегда используется в redux редьюсерах, вероятно используется где-то ещё.</p>
                    <ul>
                        <li class="green">Объявление функции: function showMessage(params) {...}, переменные, объявленные в ней, извне не доступны</li>
                        <li class="green">Внешние переменные: функция имеет доступ к переменным, объявленным выше, вне тела функции</li>
                        <li class="blue">Возврат значения: return возвращает результат, его может не быть, тогда функция вернёт undefined</li>
                        <li class="green">Именование: глагольный префикс, сделалКого, делает ровно то, что написано в её названии. Например: getUsers()</li>
                        <li class="green">Принцип «Одна функция, одно действие»: два действия, две функции, и третья, которая вызывает их обоих</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_16" id="2_16" checked>
                    <label for="2_16">2.16 Function Expression/Declaration, Callbacks</label>
                    <p class="for-what">Зачем? FE/FD используются сейчас очень редко (их заменили классы). Callbacks используются в очень многих функциях</p>
                    <ul>
                        <li class="green">Function Expression: let sayHi = function() {...}, создаётся, когда выполнение доходит до него</li>
                        <li class="green">Function Declaration: function sayHi() {...}, создаётся сразу, как только начинает работать скрипт</li>
                        <li class="blue">FD вложенная в FD будет иметь свой контекст и при обращении к this внешней функции получит undefined</li>
                        <li class="blue">Функции-«колбэки»: передаём функцию как параметр функции, она ждёт пока её вызовут, когда это будет нужно</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_17" id="2_17" checked>
                    <label for="2_17">2.17 Функции-стрелки, основы</label>
                    <p class="for-what">Зачем? Сейчас в большинстве фреймворков используются стрелочные функции. Либо классы, если нужен this, наследование итд.</p>
                    <ul>
                        <li class="green">Arrow Functions: let func = (arg1, ...argN) => expression, однострочным не нужен return, не имеют своего this</li>
                        <li class="blue">У FD/FE есть свой собственный контекс, а AF ищет контекст во внешних окружениях поочередно, от ближнего к дальнему</li>
                        <li class="blue">В методах объектов всегда запись такая objFunc(){...}, при objFunc: () => {...}, this будет равен window</li>
                    </ul>
                </div>
                <div>
                    <p class="helpful" style="padding: 10px;">
                        <span>Практика:</span><br>
                        <a href="https://jsfiddle.net/gzhel/besmp70x/13/" target="_blank">Эксперименты с потерей this, bind.</a><br>
                        <a href="https://jsfiddle.net/gzhel/69bLvyfa/105/" target="_blank">Prototype, This, Классы, Контекст, Наследование.</a>
                    </p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>3) Качество кода</b>
                <hr>
                <div>
                    <input type="checkbox" name="3_1" id="3_1" checked>
                    <label for="3_1">3.1 Отладка в браузере Chrome (Chrome DevTools)</label>
                    <p class="for-what">Зачем? Консоль используют для понимания состояний кода (вместо точек останова). Network для просмотра обмена данными.</p>
                    <ul>
                        <li class="red">Панель "Sources": слева все файлы страницы, по центру исходный код, справа зона для отладки</li>
                        <li class="green">Панель "Console": выводит логи, ошибки, можно писать в ней свои скрипты и выполнять их</li>
                        <li class="green">Панель "Network": показывает данные которые уходят и приходят с сервера, к которму стучит frontend</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="3_2" id="3_2" checked>
                    <label for="3_2">3.2 Советы по стилю кода</label>
                    <p class="for-what">Зачем? Стоит выработать свой стиль кода, чтобы чётко его понимать и переманивать команду писать именно на нём.</p>
                    <ul>
                        <li class="green">Линтеры: автоматически проверяют и ругают стиль кода, не соответствующий правилам. Лучший линтер - ESLint</li>
                        <li class="blue">В каком стиле писать код? Зависит от команды разработчиков и проекта, на который вы попали</li>
                    </ul>
                </div>
                <div style="display: none;">
                    <input type="checkbox" name="3_3" id="3_3" checked>
                    <label for="3_3">3.3 Комментарии</label>
                    <p class="orange">1) Хорошие комментарии (почему задача была решена так?)</p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>4) Объекты: основы <a href="https://jsfiddle.net/gzhel/j7tyw89L/84/" target="_blank">(примеры кода)</a></b>
                <hr>
                <div>
                    <input type="checkbox" name="4_1" id="4_1" checked>
                    <label for="4_1">4.1 Объекты</label>
                    <p class="for-what">Зачем? Объекты и массивы это самая распространенная структура данных в JS. По сути это структуризированные хранилища данных.</p>
                    <ul>
                        <li class="green">Литералы (объекты через {...}) и свойства {ключ1:значение}, обращение через obj.key, для удаления delete obj.key</li>
                        <li class="blue">Квадратные скобки: обращение через obj[key] используют когда key это переменная, либо в любом итеративном методе</li>
                        <li class="red">Свойство из переменной: запись {name: name, age: age} можем записать как {name, age}</li>
                        <li class="green">Оператор «in»: "key" in object, проверяет есть ли ключ А в объекте Б, возвращает true/false</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="4_2" id="4_2" checked>
                    <label for="4_2">4.2 Копирование объектов и ссылки</label>
                    <p class="for-what">Зачем? На этом моменте полегло множество джунов. Стоит знать об этом, чтобы не словить удивление "почему оно работает не так".</p>
                    <ul>
                        <li class="green">Копирование по ссылке для примитивов: let a = 1; let b = a; две независимые переменные, клоны, изменим Б, А не изменится</li>
                        <li class="blue">Копирование по ссылке для object: let a = {}; let b = a; переменные с ссылкой на один объект, изменим Б, изменится А</li>
                        <li class="blue">Object.assign(dest, [src1, src2...]), клон объекта, но работает только на верхний уровень вложенности, что нам не подходит</li>
                        <li class="blue">Вложенное клонирование: ключом объекта может быть объект, для клона есть lodash _.cloneDeep(obj)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="4_4" id="4_4" checked>
                    <label for="4_4">4.4 Методы объекта, "this"</label>
                    <p class="green">1) «this» в методах (объект перед точкой (user. это this для name), для доступа к тому, что внутри объекта)</p>
                    <p class="green">2) «this» не фиксирован (зависит от контекста, при вызове obj.f() значение this внутри f равно obj)</p>
                    <p class="green">3) У стрелочных функций нет «this» (его значение берётся из внешней «нормальной» функции, если такая есть)</p>
                </div>
                <div>
                    <input type="checkbox" name="4_5" id="4_5" checked>
                    <label for="4_5">4.5 Конструкторы, создание объектов через "new"</label>
                    <p class="green">1) Функция-конструктор (с большой буквы, вызов через new: function User(a) {this.a = a;} let b = new User(22);)</p>
                    <p class="green">2) Создание методов в конструкторе (в this можем добавлять методы: this.read = function() {...})</p>
                </div>
                <div>
                    <input type="checkbox" name="4_6" id="4_6" checked>
                    <label for="4_6">4.6 Опциональная цепочка '?.'</label>
                    <p class="green">1) ?. (возвращает undefined если часть перед "?." undefined или null, ошибки нет (если a в a?.b объявлена))</p>
                    <p class="orange">2) ?.() (для вызова потенциально несуществующей функции: user1.admin?.())</p>
                    <p class="orange">3) ?.[] (если значение ключа получаем с помощью [], например если оно берётся из переменной)</p>
                </div>
                <div>
                    <input type="checkbox" name="4_7" id="4_7" checked>
                    <label for="4_7">4.7 Тип данных Symbol</label>
                    <p class="orange">1) Symbol (let id = Symbol("id"); это уникальный идентификатор, уникален даже если "имя" одинаково)</p>
                </div>
                <div>
                    <input type="checkbox" name="4_8" id="4_8" checked>
                    <label for="4_8">4.8 Преобразование объектов в примитивы</label>
                    <p class="red">1) На практике используют obj.toString() «универсальный» метод для всех типов преобразований</p>
                </div>
                <div>
                    <p class="helpful" style="padding: 10px;">
                        <a href="https://jsfiddle.net/gzhel/4jo0ufvx/91/" target="_blank">Эксперименты с IIFE, call, Object.assign()</a>
                    </p>
                    <p class="blue">1) IIFE в реальных проектах чаще всего используют с замыканиями</p>
                    <p class="blue">2) IIFE просто сокращает две переменные (с обычным замыканием) до одной</p>
                    <p class="blue">3) call служит для расширения функционала (пример: у NodeList нет map, мы его можем добавить с помощью call)</p>
                    <p class="blue">4) Object.assign "безопасно копирует" только верхний уровень, для остальных он меняет значения по ссылке</p>
                    <p class="blue">5) Для полного копирования можно использовать lodash _.cloneDeep(obj)</p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>5) Типы данных <a href="https://jsfiddle.net/gzhel/3heobtq8/162/" target="_blank">(примеры кода)</a></b>
                <hr>
                <div>
                    <input type="checkbox" name="5_1" id="5_1" checked>
                    <label for="5_1">5.1 Методы у примитивов</label>
                    <p class="green">1) Примитив как объект (примитивы (кроме null/undefined) имеют объект-обёртку (String, Number, Boolean итд)</p>
                    <p class="green">2) Методы (объект-обёртка даёт примитиву использовать метод объекта, при этом примитив не становится объектом)</p>
                </div>
                <div>
                    <input type="checkbox" name="5_2" id="5_2" checked>
                    <label for="5_2">5.2 Числа (number)</label>
                    <p class="green">1) Округление (Math.floor в меньш., Math.ceil в больш., Math.round до ближ. цел., Math.trunc уд. дроб. части)</p>
                    <p class="green">2) toFixed(n) (округляет число до n знаков после запятой и возвращает строку)</p>
                    <p class="green">3) Неточные вычисления (при работе с дробями округляем их через +number.toFixed(n); иначе могут быть ошибки)</p>
                    <p class="orange">4) isFinite и isNaN (isNaN(value) это NaN? isFinite(value) это не NaN/Infinity/-Infinity?)</p>
                    <p class="orange">5) parseInt и parseFloat («читают» число из строки. parseInt('100px') // 100)</p>
                    <p class="green">6) Math.random() (число от 0 до 1), Math.max/min(a, b...) (больш./меньш. из арг.), Math.pow(n, power) (**)</p>
                </div>
                <div>
                    <p class="helpful" style="padding: 10px;">
                        <a href="https://jsfiddle.net/gzhel/cqean0o6/4/" target="_blank">Задания: cloneDeep, BigDecimal, isNaN</a><br><br>
                        <a href="https://jsfiddle.net/gzhel/s7d6x09v/47/" target="_blank">Практика: работа с видами функций</a>
                    </p>
                </div>
                <div>
                    <input type="checkbox" name="5_3" id="5_3" checked>
                    <label for="5_3">5.3 Строки (string)</label>
                    <p class="green">1) Длина строки (length содержит длину строки: alert( `My\n`.length ); // 3)</p>
                    <p class="green">2) Изменение регистра (toLowerCase() и toUpperCase() меняют регистр символов)</p>
                    <p class="orange">3) str.indexOf(substr, pos) (ищет подстроку substr в строке str, с позиции pos, возвр. подход. позицию или -1)</p>
                    <p class="orange">4) str.includes(substr, pos), str.startsWith(substr), str.endsWith(substr)</p>
                    <p class="green">5) str.slice(start [, end]) (возвращает от start до end (не включая end))</p>
                </div>
                <div>
                    <input type="checkbox" name="5_4" id="5_4" checked>
                    <label for="5_4">5.4 Массивы</label>
                    <p class="green">1) [] (с 0, получить эл. arr[id], заменить эл. arr[id] = 2, длина arr.length, могут храниться даже функц.)</p>
                    <p class="green">2) push() (доб. эл. в конец), pop () (удал. эл. в конце, а после веруть этот элемент как результат)</p>
                    <p class="green">3) unshift() (доб. эл. в начало), shift () (удал. эл. в начале, а после веруть этот элемент как результат)</p>
                    <p class="red">4) Перебор элементов (через for или for of: for (let fruit of fruits) {...})</p>
                </div>
                <div>
                    <p class="helpful" style="padding: 10px;">
                        <a href="https://jsfiddle.net/gzhel/bjusyqvk/242/" target="_blank">Задания: работа с массивами</a>
                    </p>
                </div>
                <div>
                    <input type="checkbox" name="5_5" id="5_5" checked>
                    <label for="5_5">5.5 Методы массивов</label>
                    <p>Добавление/удаление элементов:</p>
                    <p class="green">1) arr.splice(pos, deleteCount, 'item1', ...) (начиная с pos, удал. deleteCount эл., вставляет items)</p>
                    <p class="green">2) arr.slice(start, end) (создаёт новый массив, копируя в него элементы с start до end (не включая end))</p>
                    <p class="orange">3) arr.concat(arg1, arg2...) (возвр. новый массив: копир. все члены текущего массива и добавляет к нему items)</p>
                    <p>Поиск в массиве:</p>
                    <p class="green">4) arr.includes(item, from) (ищет item, начиная с индекса from, и возвращает true, если поиск успешен)</p>
                    <p class="green">5) arr.find(func)/arr.filter(func) (фильтрует элементы через функцию и отдаёт первое/все знач. которые true)</p>
                    <p>Преобразование массива:</p>
                    <p class="green">6) arr.map(func) (создаёт новый массив из результатов вызова func для каждого элемента)</p>
                    <p class="green">7) arr.sort(func) (сортирует массив, а потом возвращает его)</p>
                    <p class="orange">8) arr.reverse() (меняет порядок следования элементов на противоположный и возвращает изменённый массив)</p>
                    <p class="green">9) arr.split(char)/join(char) (преобразует строку в массив и обратно, по разделителю)</p>
                    <p class="green">10) reduce(func, initialValue) (func всегда имеет 2 параметра: accumulator, currentValue)</p>
                    <p>Дополнительно:</p>
                    <p class="green">11) arr.some(fn)/arr.every(fn) (fn выз. для каждого элемента массива, если один/все true, возвращает true)</p>
                </div>
                <div>
                    <input type="checkbox" name="5_6" id="5_6" checked>
                    <label for="5_6">5.6 Перебираемые объекты</label>
                    <p class="orange">1) for..of (в итерируемых объектах можно исп. любой объект в цикле for of, они имеют метод Symbol.iterator)</p>
                    <p class="green">2) Array.from(arrayLike) (принимает итер. объект/псевдомассив, делает из него Array с методами массивов)</p>
                </div>
                <div>
                    <input type="checkbox" name="5_7" id="5_7" checked>
                    <label for="5_7">5.7 Map и Set</label>
                    <p class="red">1) Map (коллекция ключ/значение, как и object, но Map позволяет использовать ключи любого типа, даже object)</p>
                    <p class="red">2) Set (коллекция «множество» значений (без ключей), где каждое значение может появляться только один раз)</p>
                    <p class="green">3) Синтаксис [...new Set(arr)] используется для получения только уникальных значений arr</p>
                </div>
                <div>
                    <input type="checkbox" name="5_9" id="5_9" checked>
                    <label for="5_9">5.9 Object.keys, values, entries</label>
                    <p class="green">1) Object.keys/values/entries(obj) (возвр. массив ключей/значений/пар [ключ, значение])</p>
                    <p class="orange">2) Трансформация объекта (алгоритм используется для исп. методов массива на объекте)</p>
                    <p class="orange">3) Алгоритм трансформации объекта (Object.entries(obj) -> методы массива -> Object.fromEntries(array))</p>
                </div>
                <div>
                    <input type="checkbox" name="5_10" id="5_10" checked>
                    <label for="5_10">5.10 Деструктурирующее присваивание</label>
                    <p class="green">1) Деструктуризация массива (на примере: let arr = ["Ilya", "Kantor"]; let [firstName, surname] = arr;)</p>
                    <p class="green">2) Остаточные параметры «…» ("добавить к тому что есть всё остальное": let [name1, name2, ...rest] = arr;)</p>
                    <p class="green">3) Значения по умолчанию (если парамтер не передан, берётся по умолчанию, let [name = "Guest"] = arr;)</p>
                    <p class="green">4) Деструктуризация объекта (на примере: let opts = {width: 10, height: 20}; let {width, height} = opts;)</p>
                    <p class="green">5) Остаток объекта «…» (на примере: let opts = {width: 10, height: 20}; let {width, ...rest} = opts;)</p>
                    <p class="green">6) Умные параметры функций (можем передать объект в функцию ({...}) и она сразу деструктуризирует его)</p>
                </div>
                <div>
                    <input type="checkbox" name="5_11" id="5_11" checked>
                    <label for="5_11">5.11 Дата и время</label>
                    <p class="green">1) Создание (new Date(); создать объект Date с текущими датой и временем)</p>
                    <p class="orange">2) Получение компонентов даты (getFullYear(), getMonth() (от 0 до 11), getDate(), getDay() (от 0 до 6))</p>
                    <p class="orange">3) Разность дат (даты можно вычитать, в результате получаем разность в миллисекундах)</p>
                </div>
                <div>
                    <input type="checkbox" name="5_12" id="5_12" checked>
                    <label for="5_12">5.12 Формат JSON, метод toJSON</label>
                    <p class="green">1) JSON (поддерж. простые объекты, массивы, строки, числа, логические значения и null, всё пишется через "")</p>
                    <p class="orange">2) JSON.stringify(obj) (берёт объект и преобразует его в JSON-строку)</p>
                    <p class="orange">2) JSON.parse(str) (берёт JSON-строку и декодирует её в объект)</p>
                </div>
                <div>
                    <p class="helpful" style="padding: 10px;">
                        <a href="https://jsfiddle.net/gzhel/Lw1u3d5m/170/" target="_blank">Эксперименты с reduce, деструктуризация</a>
                    </p>
                    <p class="blue">1) Зачем reduce? Он позволяет абсолютно как угодно обрабатывать элементы массива и возвращать результат</p>
                    <p class="blue">2) Полный синтаксис: reduce((accumulator, currentValue, index, array) => { ... }, initialValue)</p>
                    <p>Избегаем ошибок:</p>
                    <p class="blue">3) Если вы не передадите initialValue, то reduce() будет считать, что им является первый элемент в массиве</p>
                    <p class="blue">4) Не забывайте делать return total (1ый параметр), чтобы reduce() продолжал работать</p>
                    <p>Деструктурирующее присваивание:</p>
                    <p class="blue">5) let [field1, field2, ...rest] = arr; тут ...rest будет отдельным массивом</p>
                    <p class="blue">6) let {objVal1, ...rest} = obj; тут ...rest будет отдельным объектом ключ-значение</p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>6) Продвинутая работа с функциями <a href="https://jsfiddle.net/gzhel/fuv846rs/75/" target="_blank">(примеры кода)</a></b>
                <hr>
                <div>
                    <input type="checkbox" name="6_1" id="6_1" checked>
                    <label for="6_1">6.1 Рекурсия и стек</label>
                    <p class="green">1) Рекурсия (это когда функция в себе вызывает сама себя, какой-то if служит моментом выхода из рекурсии)</p>
                    <p class="orange">2) Контекст выполнения, стек (это данные в некоторый момент исполнения функции, рекурсивный стек выполнения)</p>
                    <p class="orange">3) Рекурсивные обходы (это использование рекурсии для объектов с большой сложной вложенностью)</p>
                    <p class="red">3) Связанный список (на примере: let li = {v: 1}; li.next = {v: 2}; li.next.next = {v: 3};)</p>
                </div>
                <div>
                    <input type="checkbox" name="6_2" id="6_2" checked>
                    <label for="6_2">6.2 Остаточные параметры и оператор расширения (...rest, ...spread)</label>
                    <p class="green">1) Остаточные параметры («собери оставшиеся параметры и положи их в массив», function sumAll(...args) {...})</p>
                    <p class="green">2) Оператор расширения («возьми массив и сократи его запись», Math.max(...arr1, ...arr2))</p>
                    <p class="green">3) Оператор расширения для слияния (его можно использовать для слияния массивов в один [...arr1, ...arr2])</p>
                </div>
                <div>
                    <input type="checkbox" name="6_3" id="6_3" checked>
                    <label for="6_3">6.3 Замыкание</label>
                    <p>Лексическое Окружение (LexicalEnvironment):</p>
                    <p class="green">1) Лексическое Окружение (у каждой функции, блока кода и скрипта есть внутренний (скрытый) объект Лекс. Окр.)</p>
                    <p class="green">2) LE: Environment Record (объект, в нём хранятся все локальные переменные, а также this)</p>
                    <p class="green">3) LE: Ссылка на внешнее лексическое окружение (код снаружи от текущих фигурных скобок)</p>
                    <p class="green">3) LE: Переменные (это свойство LE: Environment Record, мы работаем с этим объектом, а не с переменной)</p>
                    <p>Внутреннее и внешнее лексическое окружение:</p>
                    <p class="green">1) Код хочет получить доступ к переменной (поиск во внутр. LE -> внеш. LE -> ещё более внеш. LE итд)</p>
                    <p class="green">2) Переменная не была найдена (ошибка в strict mode, созд. новую глоб. перем. с этим именем без strict mode)</p>
                    <p class="orange">3) Функция получает текущее значение внешних переменных (старые значения переменных нигде не сохраняются)</p>
                    <p>Вложенные функции (замыкания):</p>
                    <p class="green">1) Когда внутренняя функция начинает вып., нач. поиск возвращаемой переменной от локал. LE к глоб. LE</p>
                    <p class="green">2) Для каждого присвоения функции переменной созд. новое LE (let f1 = f(); let f2 = f(); независимые)</p>
                    <p>Окружение в деталях:</p>
                    <p class="green">1) Когда скрипт только начинает выполняться, есть только глобальное лексическое окружение</p>
                    <p class="green">2) Далее оно смотрт на сущности (функции, переменные итд) и задаёт им возвращаемые значения</p>
                    <p class="green">3) Далее оно заглядывает внутрь функций и задаёт их LE значения, возвращ. ещё мб undefined</p>
                    <p class="green">4) Далее по принципу "матрёшки", если искомой переменной нет в локал. LE, он ищет в более глобальном LE</p>
                    <p>Блоки кода и циклы:</p>
                    <p class="green">1) LE существует для любых блоков кода {...} (и содержит локальные переменные для этого блока)</p>
                    <p class="green">2) LE для if (если переменной в if нет, она берёт её из глобального LE)</p>
                    <p class="green">3) LE для for/while (у каждой итерации своё отдельное LE, let i = 0 находится в LE, хоть внешне и не в {})</p>
                </div>
                <div>
                    <input type="checkbox" name="6_4" id="6_4" checked>
                    <label for="6_4">6.4 Устаревшее ключевое слово "var"</label>
                    <p class="red">1) Область видимости var это функция/скрипт, но не {}, {var a = 1;} доступна за пределами {}</p>
                    <p class="red">2) «var» обрабатываются в начале запуска функции (попадает в LE сразу, значение мб задано до объявления)</p>
                </div>
                <div>
                    <input type="checkbox" name="6_5" id="6_5" checked>
                    <label for="6_5">6.5 Глобальный объект (window)</label>
                    <p class="green">1) window (предоставляет переменные и функции окна браузера, доступные в любом месте программы)</p>
                    <p class="blue">2) Можно задать глобальные переменные через window (window.link = "PROJECT_PROD"</p>
                </div>
                
                <div>
                    <input type="checkbox" name="6_8" id="6_8" checked>
                    <label for="6_8">6.8 Планирование: setTimeout и setInterval</label>
                    <p class="green">1) setTimeout(func, [delay]) (вызвать функцию один раз через определённый интервал времени)</p>
                    <p class="orange">2) setInterval(func, [delay]) (вызывать функцию регулярно, повторяя вызов через delay)</p>
                    <p class="green">3) setTimeout(func) с 0 задержкой (вызовет результат функции после выполнения остального скрипта, стек)</p>
                </div>
                <div>
                    <input type="checkbox" name="6_10" id="6_10" checked>
                    <label for="6_10">6.10 Привязка контекста к функции</label>
                    <p class="orange">1) Потеря «this» (возникает при передаче методов объекта в качестве колбэков, например для setTimeout)</p>
                    <p class="green">2) Привязка «this» с помощью bind (например: bind: let boundFunc = func.bind(context); контекст не пропадёт)</p>
                    <p class="blue">3) setTimeout в браузере имеет особенность: он устанавливает this=window для вызова функции</p>
                    <p class="blue">4) Частичное применение: f.bind(null, 2); установит null как контекст и 2 как первый параметр функции f</p>
                    <p class="blue">5) Привязка А к контексту Б: let user = {name: "A"}; function f() {alert(this.name)} let fU = f.bind(user);</p>
                    <p class="helpful" style="padding: 10px;">
                        <a href="https://jsfiddle.net/gzhel/phxmLsca/36/" target="_blank">Задачи с собесов (1-13)</a>
                    </p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>7) Свойства объекта, их конфигурация <a href="https://jsfiddle.net/gzhel/nhdjf2p1/127/" target="_blank">(примеры кода)</a></b>
                <hr>
                <div>
                    <input type="checkbox" name="7_1" id="7_1">
                    <label for="7_1">7.1 Флаги и дескрипторы свойств</label>
                    <p class="red">1) Флаги свойств (объект имеет 3 доп. св-ва: writable (запись), enumerable (циклы), configurable (delete))</p>
                    <p class="red">2) Как получить их текущие значения? (let descriptor = Object.getOwnPropertyDescriptor(obj, "propertyName");)</p>
                </div>
                <div>
                    <input type="checkbox" name="7_2" id="7_2">
                    <label for="7_2">7.2 Свойства - геттеры и сеттеры (get, set)</label>
                    <p class="green">1) Свойства-аксессоры (исп. для присвоения/получения значения, но во внешнем коде выглядят как св-ва объекта)</p>
                    <p class="green">2) get (let obj = {get propName() {return this.propName;}, срабатывает, когда obj.propName читается})</p>
                    <p class="green">3) set (let obj = {set propName(val) {this.propName = val;}, срабатывает, когда obj.propName присваивается})</p>
                    <p class="green">4) Умные геттеры/сеттеры (пример:если хотим запретить уст. короткое имя user, можем исп. set name для проверки)</p>
                    <p class="helpful" style="padding: 10px;">
                        <a href="https://jsfiddle.net/gzhel/fnxym9gz/25/" target="_blank">Добавить динамически getter к пустому объекту</a>
                    </p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>9) Классы <a href="https://jsfiddle.net/gzhel/nx7e5o0r/2/" target="_blank">(примеры кода)</a></b>
                <hr>
                <div>
                    <input type="checkbox" name="9_1" id="9_1">
                    <label for="9_1">9.1 Класс: базовый синтаксис</label>
                    <p class="green">1) Синтаксис «class» (class MyClass {constructor() {...} met1() {...} итд}; let user = new MyClass("Абоба"))</p>
                    <p class="green">2) Что такое класс? (функция, её код берётся из constructor, а методы сохраняются в Class.prototype)</p>
                </div>
                <div>
                    <input type="checkbox" name="9_2" id="9_2">
                    <label for="9_2">9.2 Наследование классов</label>
                    <p class="green">1) extends (ключевое слово для наследования от другого класса: class Rabbit extends Animal {...})</p>
                    <p class="orange">2) [[Prototype]] (если искомый метод не найден в Rabbit.prototype, JS берёт его из Animal.prototype)</p>
                    <p class="green">3) Переопределение конструктора (у наследующего класса можно создать свой конструктор, но с super(value))</p>
                </div>
                <div>
                    <input type="checkbox" name="9_3" id="9_3">
                    <label for="9_3">9.3 Статические свойства и методы</label>
                    <p class="red">1) static (можем присвоить метод самой функции-классу, а не её "prototype", static methodName () {...})</p>
                </div>
                <div>
                    <input type="checkbox" name="9_4" id="9_4">
                    <label for="9_4">9.4 Приватные и защищённые методы и свойства</label>
                    <p class="green">1) Защищённые свойства (начинаются с префикса _, становятся защищёнными при помощи set с условием)</p>
                    <p class="orange">2) Приватное свойство «#something» (начинаются с префикса #, добавляет поддержку приватных свойств и методов)</p>
                </div>
                <div>
                    <input type="checkbox" name="9_6" id="9_6">
                    <label for="9_6">9.6 Проверка класса: "instanceof"</label>
                    <p class="green">1) instanceof (позволяет проверить, к какому классу принадлежит объект, с учётом наследования, true/false)</p>
                </div>
                <div>
                    <input type="checkbox" name="9_7" id="9_7">
                    <label for="9_7">9.7 Примеси</label>
                    <p class="red">1) В JS можно наследовать только от одного объекта (для таких случаев существуют «примеси»)</p>
                    <p class="helpful" style="padding: 10px;">
                        <a href="https://jsfiddle.net/gzhel/nx7e5o0r/83/" target="_blank">Практика: классы</a>
                    </p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>10) Обработка ошибок</b>
                <hr>
                <div>
                    <input type="checkbox" name="10_1" id="10_1">
                    <label for="10_1">10.1 Обработка ошибок, "try..catch"</label>
                    <p class="green">1) Синтаксис «try…catch» (код в catch -> ошибок нет? пропускаем catch : прерываем try и заходим в catch)</p>
                    <p class="green">2) Объект ошибки (при ошибке, она летит в catch и содержит: name (имя), message (детали), stack (стек вызова))</p>
                    <p class="green">3) try…catch…finally (finally вып. всегда: после try, если не было ошибок, после catch, если ошибки были)</p>
                </div>
                <div>
                    <input type="checkbox" name="10_2" id="10_2">
                    <label for="10_2">10.2 Пользовательские ошибки, расширение Error</label>
                    <p class="green">1) Расширение Error (создаём класс на основе Error, спрашиваем instanceof и предпринимаем какие-либо действия)</p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>11) Промисы, async/await <a href="https://jsfiddle.net/gzhel/fzgupj9w/118/" target="_blank">(примеры кода)</a></b>
                <hr>
                <div>
                    <input type="checkbox" name="11_1" id="11_1">
                    <label for="11_1">11.1 Введение: колбэки</label>
                    <p class="green">1) callback (передаём callback-функцию как парам. функции, на onload вызываем его когда данные загрузятся)</p>
                    <p class="orange">2) Данные не загрузились? (передаём в callback-функцию null первым агрументом на onload, и error на onerror)</p>
                    <p class="green">3) Ад коллбеков (если нужно загрузить N данных один за другим, нужно изолировать действия по разным функциям)</p>
                </div>
                <div>
                    <input type="checkbox" name="11_2" id="11_2">
                    <label for="11_2">11.2 Промисы</label>
                    <p>Основы:</p>
                    <p class="green">1) Синтаксис (let promise = new Promise(function(resolve, reject) {// функция-исполнитель, executor});)</p>
                    <p class="green">2) resolve(value) (это колбэк, если работа завершилась успешно, вернётся с результатом value)</p>
                    <p class="green">3) reject(error) (это колбэк, если произошла ошибка, вернётся с error – объектом ошибки)</p>
                    <p>Потребители: then, catch, finally:</p>
                    <p class="green">4) .then((result) => {}) (вып. когда промис в resolve, как result получает value)</p>
                    <p class="green">5) .catch((error) => {}) (вып. когда промис в reject, как error получает error)</p>
                    <p class="green">6) .finally((func) => {}) (вып. в любом случае, подходит для очистки, сброса состояний итд)</p>
                </div>
                <div>
                    <input type="checkbox" name="11_3" id="11_3">
                    <label for="11_3">11.3 Цепочка промисов</label>
                    <p class="green">1) .then и .catch можно использовать не один раз, а много, т.к. они возвращают промисы: .then.catch.then итд</p>
                </div>
                <div>
                    <input type="checkbox" name="11_4" id="11_4">
                    <label for="11_4">11.4 Промисы: обработка ошибок</label>
                    <p class="orange">1) Стоит размещать .catch там, где мы хотим обработать ошибки и знаем, как это сделать</p>
                </div>
                <div>
                    <input type="checkbox" name="11_5" id="11_5">
                    <label for="11_5">11.5 Promise API</label>
                    <p class="green">1) Promise.all(promises) (ждёт выполнения всех промисов и возвращает массив с результатами)</p>
                    <p class="green">2) Promise.race(promises) (ждёт первый вып. промис, он становится его результатом, остальные игнорируются)</p>
                </div>
                <div>
                    <input type="checkbox" name="11_6" id="11_6">
                    <label for="11_6">11.6 Промисификация</label>
                    <p class="orange">1) Берём функцию, которая принимает колбэк и меняем её, чтобы она вместо этого возвращала промис</p>
                </div>
                <div>
                    <input type="checkbox" name="11_7" id="11_7">
                    <label for="11_7">11.7 Микрозадачи (microtasks)</label>
                    <p>Очередь микрозадач (microtask queue):</p>
                    <p class="green">1) Когда промис выполнен, его обработчики .then/catch/finally попадают в очередь, пока ещё не выполняются</p>
                    <p class="green">2) JS берёт задачу из очереди и выполняет её, но позже, когда он освободится от выполнения остального кода</p>
                    <p class="green">3) Если нам важен порядок выполнения (то завернём код после в .then после остальных .then .catch)</p>
                </div>
                <div>
                    <input type="checkbox" name="11_8" id="11_8">
                    <label for="11_8">11.8 Async/await</label>
                    <p>Асинхронные функции:</p>
                    <p class="green">1) async (ставится перед функцией, возвращает промис)</p>
                    <p class="green">2) await  (let value = await promise; только в async, говорит JS ждать пока промис справа от не выполнится)</p>
                    <p class="green">3) По сути, это «синтаксический сахар» для получения результата промиса, более наглядный, чем promise.then</p>
                    <p>Обработка ошибок:</p>
                    <p class="orange">4) Промис может завершиться с ошибкой не сразу, тогда будет задержка, а затем await выбросит исключение</p>
                    <p class="green">5) try {} catch(err) {} (ошибки можно ловить через try catch, если ошибка появится, то перейдёт в catch)</p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>12) Генераторы, продвинутая итерация</b>
                <hr>
                <div>
                    <input type="checkbox" name="12_1" id="12_1">
                    <label for="12_1">12.1 Генераторы</label>
                    <p class="orange">1) Функция-генератор (function* {yield 1; yield 2;return 3}, эта функция не выполняет код, а ждёт команд)</p>
                </div>
                <div>
                    <input type="checkbox" name="11_2" id="11_2">
                    <label for="11_2">12.2 Асинхронные итераторы и генераторы</label>
                    <p class="orange">1) Подходит для выполнения сетевых запросов (можем использовать async/await)</p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>13) Модули</b>
                <hr>
                <div>
                    <input type="checkbox" name="13_1" id="13_1">
                    <label for="13_1">13.1 Модули, введение</label>
                    <p class="green">1) Модуль – это просто файл, один скрипт – это один модуль</p>
                    <p class="green">2) export (делает переменные и функции потенциально доступными вне текущего модуля)</p>
                    <p class="green">3) import (позволяет брать переменные и функции из других модулей, при наличие экспорта у них)</p>
                </div>
                <div>
                    <input type="checkbox" name="13_2" id="13_2">
                    <label for="13_2">13.2 Экспорт и импорт</label>
                    <p>Варианты вызова для export:</p>
                    <p class="green">1) Перед объявлением класса/функции/итд (export [default] class/function/variable/итд)</p>
                    <p class="green">2) Отдельный от объявления экспорт (export {x [as y], ...})</p>
                    <p class="orange">3) Реэкспорт (импортировать что-то и тут же экспортировать, export {sayHi} from './say.js';)</p>
                    <p>Варианты вызова для import:</p>
                    <p class="green">4) Именованные экспорты из модуля (import {x [as y], ...} from "module";)</p>
                    <p class="orange">5) Импорт по умолчанию (import x from "module"; (для export default))</p>
                    <p class="orange">6) Всё сразу (import * as obj from "module";)</p>
                    <p class="green">7) Только подключить модуль, но не присваивать его переменной (import "./styles.css")</p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>14) Разное</b>
                <hr>
                <div>
                    <input type="checkbox" name="14_3" id="14_3">
                    <label for="14_3">14.1 Proxy и Reflect</label>
                    <p class="green">1) Proxy это обёртка вокруг объекта/функции/класса, которая ставит "ловушки" на взаимодействие с ним</p>
                    <p class="green">2) Синтаксис: let proxy = new Proxy(target - исх. объект, handler - объект методов "ловушек")</p>
                    <p class="blue">3) Методы у прокси объекта как бы копируют базовый функционал работы с объектом, но могут его расширить</p>
                    <p class="green">4) Методы для объекта: get (obj, key), set (obj, key, value), has (obj, key), deleteProperty (obj, key)</p>
                    <p class="green">5) Методы для функций: apply (func, _this, args) // сработает когда данная функция будет вызываться</p>
                    <p class="green">6) Методы для классов: construct (class, args) // сработает при создании экземпляра класса через new</p>
                    <p class="blue">7) Можно создать "ловушку" на существующие или кастомные методы, подробнее чуть ниже:</p>
                    <p class="helpful" style="padding: 10px;">
                        <a href="https://jsfiddle.net/gzhel/31vfomgt/163/" target="_blank">Практика: Proxy</a>
                    </p>
                </div>
                <div>
                    <input type="checkbox" name="14_3" id="14_3">
                    <label for="14_3">14.3 Каррирование</label>
                    <p class="orange">1) Трансформация функций так, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c)</p>
                    <p class="green">2) lodash _.curry(f) (возвр. обёртку, даёт запустить функцию как обычным образом, так и частично)</p>
                </div>
            </div>
        </section>
    </div>
    <script>
        const showReds = document.querySelector("#show_reds");
        const hideReds = document.querySelector("#hide_reds");
        const reds = document.querySelectorAll('.red');
        showReds.addEventListener('click', () => reds.forEach(red => red.style.display = 'block'));
        hideReds.addEventListener('click', () => reds.forEach(red => red.style.display = 'none'));
    </script>
</body>
</html>