<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../styles.css">
    <title>Checklist 2.0</title>
</head>
<body>
    <div class="learn-page__layout checklist" style="padding-bottom: 50px;">
        <h1><a href="../../1_module/">Back to module 1</a></h1>
        <section class="learn-page__layout--study-block">
            <h3>Обозначения (субъективно):</h3>
            <div style="margin-bottom: 6px;"><span class="blue">Синий</span>: актуально, не очевидно, secret knowledge</div>
            <div><span class="green">Зеленый</span>: актуально, стоит изучать внимательно</div>
            <div>
                <span style="color: red">Красный</span>: допустимо, в 99% случаев не используется 
                <span><button id="show_reds">Показать "красные" пункты</button></span>
                <span><button id="hide_reds">Скрыть "красные" пункты</button></span>
            </div>
            <div style="margin-bottom: 6px;"><span class="violet">Фиолетовый</span>: актуально, расширенный полезный материал</div>
            <div style="margin-bottom: 6px;"><span class="orange">Оранжевый</span>: пока не понятно, в процессе изучения материала</div>
            <div>
                <span><button id="hide_for_what">Скрыть разделы "Зачем?"</button></span>
                <span><button id="hide_practise">Скрыть разделы "Практика"</button></span>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>1) Введение</b><hr>
                <div>
                    <input type="checkbox" name="1_2" id="1_2" checked>
                    <label for="1_2">1.2 Справочники и спецификации</label>
                    <p class="for-what">Зачем? Содержат ценную информацию о возможностях использования языка, их поддержке и так далее.</p>
                    <ul>
                        <li class="red hidden">Спецификация: https://www.ecma-international.org/publications-and-standards/standards/.</li>
                        <li class="green">Справочник: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference</li>
                        <li class="blue">Таблица совместимости: https://caniuse.com</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="1_3" id="1_3" checked>
                    <label for="1_3">1.3 Редакторы кода (IDE, Integrated Development Environment)</label>
                    <p class="for-what">Зачем? Мощные редакторы с множеством функций, которые работают в рамках целого проекта.</p>
                    <ul>
                        <li class="green">Visual Studio Code (бесплатно, но это не совсем IDE).</li>
                        <li class="blue">WebStorm (платно, большинство функционала есть "из коробки").</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>2) Основы JavaScript</b><hr>
                <div>
                    <input type="checkbox" name="2_3" id="2_3" checked>
                    <label for="2_3">2.3 Строгий режим - "use strict"</label>
                    <p class="for-what">Зачем? Для работы с легаси проектами, но вообще сейчас 99% это модульные проекты, а модули автоматически добавляют "use strict".</p>
                    <ul>
                        <li class="green">"use strict": данная строка позволяет работать старыми возможностями языка, убранными с ES6+</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_4" id="2_4" checked>
                    <label for="2_4">2.4 Переменные</label>
                    <p class="for-what">Зачем? Практически всё в JS построенно на переменных, они служат хранилищем данных для любых структур данных.</p>
                    <ul>
                        <li class="green">let: переменная, можно переопределять, имеет блочную {} область видимости</li>
                        <li class="green">const: константа, нельзя переопределять, имеет блочную {} область видимости</li>
                        <li class="red hidden">var: переменная (устаревшее), имеет область видимости файла/функции, но не блока</li>
                        <li class="green">Именование: camelCase, должны быть ясны, конкретика, но не более 2-3 слов, например: userName</li>
                        <li class="blue">Можно присвоить результат выполнения функции переменной, например: let result = sum(2, 3) // 5</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_5" id="2_5" checked>
                    <label for="2_5">2.5 Типы данных</label>
                    <p class="for-what">Зачем? Разные типы данных имеют разные методы. Работа с "примитивами" отличается от работы с "объектами" (и массивами).</p>
                    <ul>
                        <li class="green">Есть 8 типов данных: number, string, object, bool, null, undefined, BigInt (big number), Symbol</li>
                        <li class="blue">Примитивы (все типы кроме object) равны сами себе. Например: 1 === 1 // true</li>
                        <li class="blue">Объекты (и массивы, т.к. это объект) не равны сами себе. Наример: {id: 1} === {id: 1} // false</li>
                        <li class="blue">Уникальность объектов может вызвать проблему при поиске "уникального" объекта в массиве. Для этого используют filter + some</li>
                        <li class="green">Оператор typeof возвращает тип чего-либо строкой. Например: typeof 1; // "number"</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_7" id="2_7" checked>
                    <label for="2_7">2.7 Преобразование типов</label>
                    <p class="for-what">Зачем? Например, часто можем получать результат инпута типом string, бекенд ждёт number, нужно делать преобразование типов.</p>
                    <ul>
                        <li class="green">Строковое преобразование к типу string: String(value) или value + ""</li>
                        <li class="green">Численное преобразование к типу number: Number(value) или +value</li>
                        <li class="green">Логическое преобразование к типу bool: Boolean(value) или !!value</li>
                        <li class="blue">0, null, undefined, NaN, "" возвращает false, всё остальное возвращает true. Например: [], {} вернёт true</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_8" id="2_8" checked>
                    <label for="2_8">2.8 Базовые операторы, математика</label>
                    <p class="for-what">Зачем? Самый простой пример это итераторы, к примеру цикл for, который сейчас устаревает, в основном это просто часть истории.</p>
                    <ul>
                        <li class="red hidden">«унарный» (+a), «бинарный» (a + b), «операнд» (a, b - это операнды)</li>
                        <li class="green">Постфиксный инкремент (v++)/декремент (v--), увеличить, но получить результат до увеличения</li>
                        <li class="green">Префиксный инкремент (++v)/декремент (--v), увеличить, и сразу получить новый результат</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_9" id="2_9" checked>
                    <label for="2_9">2.9 Операторы сравнения</label>
                    <p class="for-what">Зачем? Сравнение используется очень часто, в тех же тернарных операторах, условиях, везде, это одна из важнейших вещей.</p>
                    <ul>
                        <li class="green">Результат сравнения имеет логический тип: let a = 3 > 2; // true</li>
                        <li class="green">Всегда стоит использовать строгое сравнение (===, !==), оно проверяет не только на значение, но и на тип данных</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_10" id="2_10" checked>
                    <label for="2_10">2.10 Условное ветвление: if, '?'</label>
                    <p class="for-what">Зачем? Довольно распространено в комбинации с return, если А, то верни А1, если Б, то верни Б1 и так далее.</p>
                    <ul>
                        <li class="green">if (condition) {...}, к нему опционально идёт: else if (condition) {...} else {...}</li>
                        <li class="green">Тернарный оператор "?". Пример: let result = условие ? значение1 : значение2;</li>
                        <li class="blue">Часто в функциях используют if (condition) {return ...}, это позволяет выйти из функции и вернуть значение по условию</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_11" id="2_11" checked>
                    <label for="2_11">2.11 Логические операторы</label>
                    <p class="for-what">Зачем? Часто используются для присвоения булевых значений переменным, либо для рендера компонентов если цепочка условий true.</p>
                    <ul>
                        <li class="green">ИЛИ «||» находит первое значение равное true, либо возвращает последнее значение в цепочке. Пример: 0 || 1 || 2 // 1</li>
                        <li class="green">И «&&» находит первое значение равное false, либо возвращает последнее значение в цепочке. Пример: 1 && 0 && 2 // 0</li>
                        <li class="green">НЕ «!» приводит аргумент к bool, возвращает противоположное значение. Пример: !1 // false</li>
                        <li class="red hidden">Объединение с null '??': возвращает первое определённое значение (в отлчие от || различает false, 0, "" и null/undefined)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_13" id="2_13" checked>
                    <label for="2_13">2.13 Циклы while и for</label>
                    <p class="for-what">Зачем? Уже буквально все циклы можно считать устаревшими, вместо них используют перебирающие методы, просто часть истории.</p>
                    <ul>
                        <li class="red hidden">Цикл «while»: while (condition) {...}, цикл выполняется, пока условие condition истинно</li>
                        <li class="red hidden">Цикл «do...while»: выполнит тело, а затем проверит условие condition, и пока его значение равно true</li>
                        <li class="red hidden">Цикл «for»: for (начало; условие; шаг) {тело}, послед.: начало => (условие -> тело -> шаг -> условие)}</li>
                        <li class="red hidden">Прерывание цикла «break»: позволяет выйти из цикла, if (!value) {break;}</li>
                        <li class="blue">Обычные циклы устарели, используйте перебираемые методы (map, filter, forEach и так далее)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_14" id="2_14" checked>
                    <label for="2_14">2.14 Конструкция "switch"</label>
                    <p class="for-what">Зачем? Исходя из моего опыта, могу сказать, что всегда используется в redux редьюсерах, вероятно используется где-то ещё.</p>
                    <ul>
                        <li class="green">switch(x) {case 'val1': ... break; default: ... break;}, проверка строгая (===), case могут быть слитно (на 2 case 1 действие)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_15" id="2_15" checked>
                    <label for="2_15">2.15 Функции</label>
                    <p class="for-what">Зачем? Исходя из моего опыта, могу сказать, что всегда используется в redux редьюсерах, вероятно используется где-то ещё.</p>
                    <ul>
                        <li class="green">Объявление функции: function showMessage(params) {...}, переменные, объявленные в ней, извне не доступны</li>
                        <li class="green">Внешние переменные: функция имеет доступ к переменным, объявленным выше, вне тела функции</li>
                        <li class="blue">Возврат значения: return возвращает результат, его может не быть, тогда функция вернёт undefined</li>
                        <li class="green">Именование: глагольный префикс, сделалКого, делает ровно то, что написано в её названии. Например: getUsers()</li>
                        <li class="green">Принцип «Одна функция, одно действие»: два действия, две функции, и третья, которая вызывает их обоих</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_16" id="2_16" checked>
                    <label for="2_16">2.16 Function Expression/Declaration, Callbacks</label>
                    <p class="for-what">Зачем? FE/FD используются сейчас очень редко (их заменили классы). Callbacks используются в очень многих функциях</p>
                    <ul>
                        <li class="green">Function Expression: let sayHi = function() {...}, создаётся, когда выполнение доходит до него</li>
                        <li class="green">Function Declaration: function sayHi() {...}, создаётся сразу, как только начинает работать скрипт</li>
                        <li class="blue">FD вложенная в FD будет иметь свой контекст и при обращении к this внешней функции получит undefined</li>
                        <li class="blue">Функции-«колбэки»: передаём функцию как параметр функции, она ждёт пока её вызовут, когда это будет нужно</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="2_17" id="2_17" checked>
                    <label for="2_17">2.17 Функции-стрелки, основы</label>
                    <p class="for-what">Зачем? Сейчас в большинстве фреймворков используются стрелочные функции. Либо классы, если нужен this, наследование итд.</p>
                    <ul>
                        <li class="green">Arrow Functions: let func = (arg1, ...argN) => expression, однострочным не нужен return, не имеют своего this</li>
                        <li class="blue">У FD/FE есть свой собственный контекст, а AF ищет контекст во внешних окружениях поочередно, от ближнего к дальнему</li>
                        <li class="blue">В методах объектов всегда запись такая objFunc(){...}, при objFunc: () => {...}, this будет равен window</li>
                    </ul>
                </div>
                <div>
                    <p class="helpful" style="padding: 10px;">
                        <span>Практика:</span><br>
                        <a href="https://jsfiddle.net/gzhel/besmp70x/13/" target="_blank">Эксперименты с потерей this, bind.</a><br>
                        <a href="https://jsfiddle.net/gzhel/69bLvyfa/105/" target="_blank">Prototype, This, Классы, Контекст, Наследование.</a><br><br>
                        <span>Примеры кода:</span><br>
                        <a href="https://jsfiddle.net/gzhel/o1hn3bg6/127/" target="_blank">(примеры кода)</a>
                    </p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>3) Качество кода</b>
                <hr>
                <div>
                    <input type="checkbox" name="3_1" id="3_1" checked>
                    <label for="3_1">3.1 Отладка в браузере Chrome (Chrome DevTools)</label>
                    <p class="for-what">Зачем? Консоль используют для понимания состояний кода (вместо точек останова). Network для просмотра обмена данными.</p>
                    <ul>
                        <li class="red hidden">Панель "Sources": слева все файлы страницы, по центру исходный код, справа зона для отладки</li>
                        <li class="green">Панель "Console": выводит логи, ошибки, можно писать в ней свои скрипты и выполнять их</li>
                        <li class="green">Панель "Network": показывает данные которые уходят и приходят с сервера, к которму стучит frontend</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="3_2" id="3_2" checked>
                    <label for="3_2">3.2 Советы по стилю кода</label>
                    <p class="for-what">Зачем? Стоит выработать свой стиль кода, чтобы чётко его понимать и переманивать команду писать именно на нём.</p>
                    <ul>
                        <li class="green">Линтеры: автоматически проверяют и ругают стиль кода, не соответствующий правилам. Лучший линтер - ESLint</li>
                        <li class="blue">В каком стиле писать код? Зависит от команды разработчиков и проекта, на который вы попали</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="3_6" id="3_6" checked>
                    <label for="3_6">3.6 Полифилы</label>
                    <p class="for-what">Зачем? Чтобы современные функции поддерживались в старых движках, надо установить транспилер и добавить полифил.</p>
                    <ul>
                        <li class="green">Термин «полифил» означает, что скрипт «заполняет» пробелы и добавляет современные функции.</li>
                        <li class="blue">Babel: это транспилер, который переписывает современный JavaScript-код в предыдущий стандарт.</li>
                        <li class="blue">Но ещё Babel: это полифил, позволяющий реализовать новые встроеннные функции</li>
                    </ul>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>4) Объекты: основы</b>
                <hr>
                <div>
                    <input type="checkbox" name="4_1" id="4_1" checked>
                    <label for="4_1">4.1 Объекты</label>
                    <p class="for-what">Зачем? Объекты и массивы это самая распространенная структура данных в JS. По сути это структуризированные хранилища данных.</p>
                    <ul>
                        <li class="green">Литералы (объекты через {...}) и свойства {ключ1:значение}, обращение через obj.key, для удаления delete obj.key</li>
                        <li class="blue">Квадратные скобки: обращение через obj[key] используют когда key это переменная, либо в любом итеративном методе</li>
                        <li class="red hidden">Свойство из переменной: запись {name: name, age: age} можем записать как {name, age}</li>
                        <li class="green">Оператор «in»: "key" in object, проверяет есть ли ключ А в объекте Б, возвращает true/false</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="4_2" id="4_2" checked>
                    <label for="4_2">4.2 Копирование объектов и ссылки</label>
                    <p class="for-what">Зачем? На этом моменте полегло множество джунов. Стоит знать об этом, чтобы не словить удивление "почему оно работает не так".</p>
                    <ul>
                        <li class="green">Копирование по ссылке для примитивов: let a = 1; let b = a; две независимые переменные, клоны, изменим Б, А не изменится</li>
                        <li class="blue">Копирование по ссылке для object: let a = {}; let b = a; переменные с ссылкой на один объект, изменим Б, изменится А</li>
                        <li class="blue">Object.assign(dest, [src1, src2...]), клон объекта, но работает только на верхний уровень вложенности, что нам не подходит</li>
                        <li class="blue">Вложенное клонирование: ключом объекта может быть объект, для клона есть lodash _.cloneDeep(obj)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="4_4" id="4_4" checked>
                    <label for="4_4">4.4 Методы объекта, "this"</label>
                    <p class="for-what">Зачем? Вообще, об этом часто спрашивают на собесах, а также если нам нужно взять и использвать данные из вне.</p>
                    <ul>
                        <li class="green">Для сущности после точки "." this это всегда объект перед точкой. Пример: let userName = user.name; user это this для name</li>
                        <li class="blue">Напоминаю: у FD/FE есть свой контекст, а AF ищет контекст во внешних окружениях поочередно, от ближнего к дальнему</li>
                        <li class="blue">Проблема потери this: когда у FD/FE внутри есть дочерние FD/FE, у них this будет не внешний, а свой, фикс через AF/bind</li>
                        <li class="blue">Метод func.bind(this, arg1...) привязывает функцию к контексту this (то есть к контексту например другой функции, чего угодно)</li>
                        <li class="green">Метод func.call(this, arg1...) может расширить функционал. Пример: у NodeList нет map, мы его можем добавить с помощью call</li>
                        <li class="violet">Главное правило контекста: this указывает на тот объект, что стоит слева от точки, в контексте которого оно было вызвано</li>
                        <li class="violet">Правило с this отлично работает с расширениеем базовых классов. Пример: Array.prototype.multBy(n) = () => this.map(i => i * n)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="4_5" id="4_5" checked>
                    
                    <label for="4_5">4.5 Конструкторы, создание объектов через "new"</label>
                    <p class="for-what">Зачем? Создаём через "new" экземпляр класса или функции-конструктора, а они в свою очередь бывают иногда нужны.</p>
                    <ul>
                        <li class="green">Функция-конструктор: с большой буквы, вызов через new: function User(a) {this.a = a;} let b = new User(22);</li>
                        <li class="red hidden">Создание методов в конструкторе: в this можем добавлять методы: this.read = function() {...}</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="4_6" id="4_6" checked>
                    <label for="4_6">4.6 Опциональная цепочка '?.'</label>
                    <p class="for-what">Зачем? Фича, которая спасла нервы многих разрабов, раньше если поле "ещё не загрузилось", а DOM загрузился, кидало ошибку.</p>
                    <ul>
                        <li class="green">?. : возвращает undefined если часть перед "?." undefined или null, ошибки нет (если a в a?.b объявлена, т.е. существует)</li>
                        <li class="red hidden">?.() : для вызова потенциально несуществующей функции: user1.admin?.()</li>
                        <li class="red hidden">?.[] : если значение ключа получаем с помощью [], например если оно берётся из переменной</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="4_7" id="4_7" checked>
                    <label for="4_7">4.7 Тип данных Symbol</label>
                    <p class="for-what">Зачем? Используется для создания уникальных идентификаторов, защита данных, а также "системные символы".</p>
                    <ul>
                        <li class="green"> Symbol: это уникальный идентификатор, уникален даже если "имя" одинаково. Синтаксис: Symbol: let id = Symbol("id");</li>
                        <li class="blue">Ключи Symbol игнорируются циклом for...in. Пример: вывод ключей объекта, будут выведены все, кроме созданных с Symbol</li>
                        <li class="red hidden">Symbol.for("key"): если Symbol с "key" не существует, создаст, в другом случае считает из существующего. id === id2 // true</li>
                        <li class="red hidden">Symbol.keyFor(symbol): обратный методу Symbol.for, по symbol получаем поле "key", или undefined если символ не глобальный</li>
                        <li class="blue">Системные символы: позволяет изменять встроенное поведение объектов. Пример: Symbol.iterator, Symbol.toPrimitive</li>
                    </ul>
                </div>
                <div>
                    <p class="helpful" style="padding: 10px;">
                        <span>Примеры кода:</span><br>
                        <a href="https://jsfiddle.net/gzhel/j7tyw89L/84/" target="_blank">(примеры кода)</a><br><br>
                        <span>Практика</span><br>
                        <a href="https://jsfiddle.net/gzhel/hp5xr2k6/52/" target="_blank">Тип данных Symbol</a>
                    </p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>5) Типы данных </b>
                <hr>
                <div>
                    <input type="checkbox" name="5_1" id="5_1" checked>
                    <label for="5_1">5.1 Методы у примитивов</label>
                    <p class="for-what">Зачем? Стоит в первую очередь понимать, что примитив всегда обёрнут объектом-обёрткой, т.е. 1 === Number(1) // true.</p>
                    <ul>
                        <li class="green">Все примитивы кроме null/undefined имеют объект-обёртку (класс-обёртку) (String, Number, Boolean и так далее)</li>
                        <li class="green">Объект-обёртка даёт примитиву использовать методы класса, при этом примитив не становится объектом-обёрткой</li>
                        <li class="blue">Стоит понимать что классы-обёртки это классы, у которых есть свои данные. Пример: Number().constructor.MAX_VALUE</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="5_2" id="5_2" checked>
                    <label for="5_2">5.2 Числа (number)</label>
                    <p class="for-what">Зачем? Округление часто используется в разработке, а тажке стоит знать про "неточные вычисления", чтобы не попасть в просак.</p>
                    <ul>
                        <li class="green">Округление: Math.floor в меньшую, Math.ceil в большую, Math.round до ближайшего целого, Math.trunc удаление дробной части</li>
                        <li class="green">Метод num.toFixed(n): округляет число до n знаков после запятой и возвращает строку, нужно для фикса неточных вычислений</li>
                        <li class="blue">Неточные вычисления: это баг JS, когда например 0.1 + 0.2 = 0.30000000000000004. Всегда округляем такое через +num.toFixed(n)</li>
                        <li class="red hidden">isFinite(val) проверяет что val это не NaN/Infinity/-Infinity, isNaN(val) проверяет что val это NaN</li>
                        <li class="red hidden">parseInt и parseFloat: «читают» число из строки. parseInt('100px') // 100</li>
                        <li class="green">Math.random(): возвращает число от 0 до 1, Math.floor(Math.random() * max) вовзвращает число от 0 до max</li>
                        <li class="green">Math.max/min(a, b, c...): возвращает большее или меньшее из списка указанных элементов</li>
                        <li class="red hidden">Math.pow(n, power): возвращает n возведенное в степень power, но на мой взгляд гораздо быстрее использовать n ** power</li>
                    </ul>
                </div>
                <div>
                    <p class="helpful" style="padding: 10px;">
                        <span>Задания:</span><br>
                        <a href="https://jsfiddle.net/gzhel/cqean0o6/4/" target="_blank">cloneDeep, BigDecimal, isNaN</a><br><br>
                        <span>Практика:</span><br>
                        <a href="https://jsfiddle.net/gzhel/s7d6x09v/47/" target="_blank">Работа с видами функций</a>
                    </p>
                </div>
                <div>
                    <input type="checkbox" name="5_3" id="5_3" checked>
                    <label for="5_3">5.3 Строки (string)</label>
                    <p class="for-what">Зачем? Работа со строками не так часто встречается в разработке, но иногда используют length и slice у строк.</p>
                    <ul>
                        <li class="green">Ключ объекта строки называемый "length" содержит длину этой строки, без спецсимволов. Пример: alert( `My\n`.length ); // 3)</li>
                        <li class="green">Методы для изменения регистра: toLowerCase() и toUpperCase() меняют регистр символов на верхний и нижний соответственно </li>
                        <li class="red hidden">Метод str.indexOf(substr, pos): ищет подстроку substr в строке str, с позиции pos, возвр. подход. позицию или -1</li>
                        <li class="red hidden">Метод str.includes(substr, pos) ищет подстроку начиная с выбранной позиции, возвращает true/false</li>
                        <li class="green">Методы str.startsWith(substr), str.endsWith(substr) возвращают true/false, если строка начинается/не начинается с подстроки</li>
                        <li class="green">Метод str.slice(start [, end]): возвращает часть строки от start до end (не включая end)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="5_4" id="5_4" checked>
                    <label for="5_4">5.4 Массивы</label>
                    <p class="for-what">Зачем? Массивы и объекты это самая "обрабатывая" структура данных в JS, часто нужно забрать массив по API и обработать.</p>
                    <ul>
                        <li class="green">Основы: массив начинается с 0, получить эл. arr[id], заменить эл. arr[id] = 2, длина arr.length, можно хранить функции</li>
                        <li class="green">Метод push() добавить элемент в конец, метод pop () удалить элемент в конце, а после веруть этот элемент как результат</li>
                        <li class="green">Метод unshift(a, b...) добавить элемент(ы) в начало, метод shift() удалить элемент в начале, а после веруть как результат</li>
                        <li class="red hidden">Перебор элементов через цикл for of: for (let fruit of fruits) {...}</li>
                    </ul>
                </div>
                <div>
                    <p class="helpful" style="padding: 10px;">
                        <span>Задания:</span><br>
                        <a href="https://jsfiddle.net/gzhel/bjusyqvk/242/" target="_blank">Работа с массивами</a>
                    </p>
                </div>
                <div>
                    <input type="checkbox" name="5_5_1" id="5_5_1" checked>
                    <label for="5_5_1">5.5.1 Методы массивов: Добавление/удаление элементов</label>
                    <p class="for-what">Зачем? Часто используется как промежуточное действие в преобразование массива, чаще всего используют slice.</p>
                    <ul>
                        <li class="green">Метод arr.splice(pos, deleteCount, 'item1', ...): начиная с pos, удалить deleteCount элементов, и вставить туда items</li>
                        <li class="green">Метод arr.slice(start, end): создаёт новый массив, копируя в него элементы с start до end (не включая end)</li>
                        <li class="green">Метод arr.concat(arg1, arg2...): возвращает новый массив, копирует все члены текущего массива и добавляет к нему items</li>
                        <li class="blue">У метода concat есть современный синтаксис, который выглядит как [...arr1, ...arr2]</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="5_5_2" id="5_5_2" checked>
                    <label for="5_5_2">5.5.2 Методы массивов: Поиск в массиве</label>
                    <p class="for-what">Зачем? Например поиск по интервалу дат, или поиск на сайте, поиск чего угодно, делается через эти методы.</p>
                    <ul>
                        <li class="green">Метод arr.includes(item, from): ищет item, начиная с индекса from, и возвращает true, если поиск успешен</li>
                        <li class="green">Метод arr.find(func)/arr.filter(func): фильтрует элементы через функцию и отдаёт первое/все значение, которые true</li>
                        <li class="green">Метод arr.some(fn)/arr.every(fn): fn вызывается для каждого элемента массива, если один/все true, возвращает true)</li>
                        <li class="blue">Поиск уникальных объектов в массиве: не через includes, а через filter + some, т.к. {id: 1} === {id: 1} // false</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="5_5_3" id="5_5_3" checked>
                    <label for="5_5_3">5.5.3 Методы массивов: Преобразование массива. Стандартные методы</label>
                    <p class="for-what">Зачем? Часто используется как промежуточное действие в преобразование массива, чаще всего используют slice.</p>
                    <ul>
                        <li class="green">Метод arr.map(func): создаёт новый массив из результатов вызова func для каждого элемента, возвращает обработанные данные</li>
                        <li class="green">Метод arr.sort(arr): сортирует массив, а потом возвращает его, есть несколько форм параметров, основные: arr, compareFn</li>
                        <li class="blue">Метод arr.sort(compareFn): сортирует массив по признаку указанному в функции. Пример: arr.sort((a, b) => a - b);</li>
                        <li class="green">Метод arr.reverse(): меняет порядок следования элементов на противоположный и возвращает изменённый массив, юзают после sort</li>
                        <li class="green">Метод arr.split(char) строка в массив по разделителю char, метод join(char) массив в строку с разделителем char</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="5_5_4" id="5_5_4" checked>
                    <label for="5_5_4">5.5.4 Методы массивов: Преобразование массива. Универсальный метод reduce</label>
                    <p class="for-what">Зачем? Он позволяет как угодно обрабатывать элементы массива и возвращать результат, если другие методы не справляются.</p>
                    <ul>
                        <li class="green">Метод arr.reduce(callbackFn, initialValue): берёт любую итерируемую структуру данных, преобразует её как угодно нам</li>
                        <li class="blue">callbackFn имеет (на самом деле) 4 параметра: accumulator, currentValue, index (индекс итерации), array (исходный массив)</li>
                        <li class="blue">Для чего нужен index и array: если нам нужно получить в текущей итерации следующий элемент делаем так array[index + 1]</li>
                        <li class="blue">Избегаем ошибок: если вы не передадите initialValue, то reduce() будет считать, что им является первый элемент в массиве</li>
                        <li class="blue">Избегаем ошибок: делайте return accumulator, чтобы reduce() продолжал итерации, можно добавить if и модифицировать итерации</li>
                    </ul>
                    <p class="helpful" style="padding: 10px;">
                        <span>Практика:</span><br>
                        <a href="https://jsfiddle.net/gzhel/Lw1u3d5m/170/" target="_blank">Эксперименты с reduce, деструктуризация</a>
                    </p>
                </div>
                <div>
                    <input type="checkbox" name="5_6" id="5_6" checked>
                    <label for="5_6">5.6 Перебираемые объекты</label>
                    <p class="for-what">Зачем? Позволяет использовать любой объект в цикле for..of, без этого в нём могут итерироваться только Array, Map, Set, String.</p>
                    <ul>
                        <li class="blue">Symbol.iterator: это "ключ" объекта, представляющий собой все значения этого объекта, поочередно (см. пример)</li>
                        <li class="green">Итерируемые объекты: это объекты, которые реализуют метод Symbol.iterator, как было описано выше</li>
                        <li class="green">Псевдомассивы: это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы</li>
                        <li class="blue">Метод Array.from(arrayLikeObj): принимает итерируемый объект или псевдомассив и делает из него настоящий массив</li>
                    </ul>
                    <p class="helpful" style="padding: 10px;">
                        <span>Практика:</span><br>
                        <a href="https://jsfiddle.net/gzhel/hL035w4k/13/" target="_blank">Перебираемые объекты</a>
                    </p>
                </div>
                <div>
                    <input type="checkbox" name="5_7" id="5_7" checked>
                    <label for="5_7">5.7 Map и Set</label>
                    <p class="for-what">Зачем? По сути незачем, но в них есть интересная фича, способ получить уникальные значения (но можно получить и по другому).</p>
                    <ul>
                        <li class="red hidden">Map: коллекция ключ/значение, как и object, но Map позволяет использовать ключи любого типа, даже object</li>
                        <li class="red hidden">Set: коллекция «множество» значений (без ключей), где каждое значение может появляться только один раз</li>
                        <li class="blue">Синтаксис [...new Set(arr)] используется для получения только уникальных значений arr, не работает на объекты</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="5_9" id="5_9" checked>
                    <label for="5_9">5.9 Object.keys, values, entries</label>
                    <p class="for-what">Зачем? Не так часто, но бывают моменты, когда нужно получить массив ключей объекта, значений гораздо реже.</p>
                    <ul>
                        <li class="green">Object.keys/values/entries(obj): возвращает массив ключей/значений/пар [ключ, значение] объекта, соответственно</li>
                        <li class="red hidden">Трансформация объекта: алгоритм используется для использования методов массива на объекте</li>
                        <li class="red hidden">Алгоритм трансформации объекта: Object.entries(obj) -> методы массива -> Object.fromEntries(array)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="5_10" id="5_10" checked>
                    <label for="5_10">5.10 Деструктурирующее присваивание</label>
                    <p class="for-what">Зачем? Очень часто используется ...rest parameters, да и деструктуризация тоже используется, чтобы не писать лишний код.</p>
                    <ul>
                        <li class="green">Деструктуризация массива. Пример: let arr = ["Ilya", "Kantor"]; let [firstName, surname] = arr;</li>
                        <li class="blue">...rest parameters: "добавить к тому что есть всё остальное". Пример: let [name1, name2, ...rest] = arr;</li>
                        <li class="green">Значения по умолчанию: если парамтер не передан, берётся по умолчанию. Пример: let [name = "Guest"] = arr;</li>
                        <li class="green">Деструктуризация объекта. Пример: let opts = {width: 10, height: 20}; let {width, height} = opts;</li>
                        <li class="blue">...rest parameters for object. Пример: let opts = {width: 10, height: 20}; let {width, ...rest} = opts;</li>
                        <li class="green">Умные параметры функций: можем передать объект ключей объекта в функцию ({...}) и она сразу деструктуризирует его</li>
                        <li class="blue">Для let [field1, ...rest] = arr; и let {objVal1, ...rest} = obj; будут отдельным массиом/объектом соответственно</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="5_11" id="5_11" checked>
                    <label for="5_11">5.11 Дата и время</label>
                    <p class="for-what">Зачем? Работа с датами бывает часто для поиску по дате, стоит понимать new Date(), и знать методы либы moment js.</p>
                    <ul>
                        <li class="green">Создание новой даты: new Date("date"); создать объект Date с текущими датой и временем, "date" опционален</li>
                        <li class="blue">Есть библиотека moment, которая решает подовляющее большинство проблем, которые могут возникнуть при работе с датами</li>
                        <li class="blue">Можно использовать вместе с sort чтобы получить даты по возрастанию: dates.sort((a, b) => new Date(b.date) - new Date(a.date));</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="5_12" id="5_12" checked>
                    <label for="5_12">5.12 Формат JSON, метод toJSON</label>
                    <p class="for-what">Зачем? Сейчас методы JSON практически не используют, а так стоит просто понимать что это такое, для общего развития.</p>
                    <ul>
                        <li class="green">JSON: поддерживает простые объекты, массивы, строки, числа, логические значения и null, всё пишется через ""</li>
                        <li class="red hidden">JSON.stringify(obj): берёт объект и преобразует его в JSON-строку</li>
                        <li class="red hidden">JSON.parse(str): берёт JSON-строку и декодирует её в объект</li>
                    </ul>
                </div>
                <div>
                    <p class="helpful" style="padding: 10px;">
                        <span>Примеры кода:</span><br>
                        <a href="https://jsfiddle.net/gzhel/3heobtq8/162/" target="_blank">(примеры кода)</a>
                    </p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>6) Продвинутая работа с функциями </b>
                <hr>
                <div>
                    <input type="checkbox" name="6_1" id="6_1" checked>
                    <label for="6_1">6.1 Рекурсия и стек</label>
                    <p class="for-what">Зачем? Как правило рекурсия может пригодиться в reduce или при "глубокой" обработке объекта или массива массивов.</p>
                    <ul>
                        <li class="green">Рекурсия: это когда функция в себе вызывает сама себя, до тех пор, пока какой-то if не сработает и не выйдет из цикла</li>
                        <li class="red hidden">Рекурсивные обходы: это использование рекурсии для объектов с большой сложной вложенностью</li>
                        <li class="red hidden">Связанный список, обычно используется для бекенда. Пример: let li = {v: 1}; li.next = {v: 2}; li.next.next = {v: 3};</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="6_2" id="6_2" checked>
                    <label for="6_2">6.2 Остаточные параметры и оператор расширения (...rest, ...spread)</label>
                    <p class="for-what">Зачем? Остаточные параметры (rest parameters) используются в функциях, а оператор расширения в объектах/массивах (spread).</p>
                    <ul>
                        <li class="green">...rest parameters: «собери оставшиеся параметры и положи их в массив/объект». Пример: function sumAll(...args) {...}</li>
                        <li class="green">...spread operator: «возьми массив и сократи его запись». Пример: Math.max(...arr1, ...arr2)</li>
                        <li class="blue">Остаточные параметры могут использоваться единственным параметром, если мы не знаем, сколько параметров может ждать функция</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="6_3_1" id="6_3_1" checked>
                    <label for="6_3_1">6.3.1 Замыкания. Лексическое Окружение (LexicalEnvironment)</label>
                    <p class="for-what">Зачем? Это "невидимая" основа того, как вообще выполняются строки кода в JS, нужно для понимания того, как работает код.</p>
                    <ul>
                        <li class="green">У каждой функции, блока кода и скрипта есть внутренний (скрытый) объект LexicalEnvironment, содержащий два других поля</li>
                        <li class="green">LE: Environment Record: это скрытый объект, в нём хранятся все локальные переменные, а также текущий this</li>
                        <li class="green">LE: Ссылка на внешнее лексическое окружение: любой LE имеет ссылку на код снаружи от текущих фигурных скобок</li>
                        <li class="blue">LE: Переменные: на самом деле мы работаем не с переменными, а с объектом LE, в которм есть эти переменные</li>
                        <li class="blue">Когда код хочет получить доступ к переменной: идёт поиск во внутреннем LE -> внеш. LE -> ещё более внеш. LE итд</li>
                        <li class="blue">Когда код хочет получить доступ к переменной: идёт поиск во внутреннем LE -> внеш. LE -> ещё более внеш. LE итд</li>
                        <li class="green">
                            Когда скрипт начал выполняться, есть только глобальное LE, оно сморит на сущности и задаёт им возвращаемые значения, после чего заглядывает
                            внутрь этих сущностей и задаёт их значения LE. Далее по принципу матрёшки.
                        </li>
                        <li class="blue">Ключевой момент: функция вернёт то значение, которое ближе к return внутри её Лексического окружения</li>
                        <li class="red hidden">LE для for/while: у каждой итерации своё отдельное LE, let i = 0 находится в LE, хоть внешне и не в {}</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="6_3_2" id="6_3_2" checked>
                    <label for="6_3_2">6.3.2 Замыкания. Вложенные функции (замыкания)</label>
                    <p class="for-what">Зачем? Замыкания используются часто, это способ инкапсуляции данных при работе с функциями, удобно работать с IIFE.</p>
                    <ul>
                        <li class="green">Замыкание это функция, которая возвращает функцию. Пример: const c = (a) => (b) => a + b; let n = c(1)(2); // 3</li>
                        <li class="green">Уже переменной мы можем присвоить результат выполнения замыкания: let param = closureTest(2);</li>
                        <li class="blue">Ключевым моментом служит создание переменных внутри функций замыканий, которые не достпуны из вне</li>
                        <li class="blue">Для каждого присвоения функции переменной создаётся новое LE. Пример: let f1 = f(); независимо от let f2 = f(); </li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="6_3_3" id="6_3_3" checked>
                    <label for="6_3_3">6.3.3 Замыкания. IIFE (самовызывающаяся функция)</label>
                    <p class="for-what">Зачем? Позволяет вызвать замыкание без параметров не присваевая его результат переменной, да и в целом это всё.</p>
                    <ul>
                        <li class="green"> IIFE часто используют с замыканиями. Пример: const c = (() => () => 3)(); c(); // 3</li>
                    </ul>
                    <p class="helpful" style="padding: 10px;">
                        <a href="https://jsfiddle.net/gzhel/4jo0ufvx/91/" target="_blank">Эксперименты с IIFE, call, Object.assign()</a>
                    </p>
                </div>
                <div>
                    <input type="checkbox" name="6_4" id="6_4" checked>
                    <label for="6_4">6.4 Устаревшее ключевое слово "var"</label>
                    <p class="for-what">Зачем? Сейчас ну прям вообще не используется, разве что могут спросить на собеседовании как оно работает.</p>
                    <ul>
                        <li class="red hidden">Область видимости var это функция/скрипт, но не {}, {var a = 1;} доступна за пределами {}</li>
                        <li class="blue">«var» обрабатываются в начале запуска функци: (попадает в LE сразу, значение мб задано до объявления</li>
                    </ul>
                    
                </div>
                <div>
                    <input type="checkbox" name="6_5" id="6_5" checked>
                    <label for="6_5">6.5 Глобальный объект (window)</label>
                    <p class="for-what">Зачем? Позволяет использовать методы для работы с окнами браузера, записывать (хардкодить) переменные.</p>
                    <ul>
                        <li class="green">window: предоставляет переменные и функции окна браузера, доступные в любом месте программы</li>
                        <li class="blue">window имеет набор методов: onresize, onscroll, onload, onfocus/onblur на которые можно повесить ловушки</li>
                        <li class="blue">window.open(url, name, params): позволяет открыть новое окно (document) с указанными параметрами</li>
                        <li class="blue">Можно задать глобальные переменные через window. Пример: window.link = "PROJECT_PROD"</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="6_8" id="6_8" checked>
                    <label for="6_8">6.8 Планирование: setTimeout и setInterval</label>
                    <p class="for-what">Зачем? Сейчас используется редко, но setInterval это старый аналог WebSocket, а setTimeout старый аналог async функций.</p>
                    <ul>
                        <li class="green">setTimeout(func, [delay]): вызвать функцию через определённый интервал времени, возвращает id таймаута для clearInterval</li>
                        <li class="red hidden">setInterval(func, [delay]): вызывать функцию регулярно, повторяя вызов через промежуток времени delay</li>
                        <li class="blue">setTimeout(func) с 0 задержкой: вызовет результат выполнения func после выполнения остального скрипта (Event Loop)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="6_10" id="6_10" checked>
                    <label for="6_10">6.10 Привязка контекста к функции</label>
                    <p class="for-what">Зачем? Сейчас this используется не так часто, в основном внутри классов, либо для написания ООП библиотек.</p>
                    <ul>
                        <li class="blue">Потеря «this»: возникает когда хотим передать метод объекта как callbackFn для setTimeout</li>
                        <li class="green">Привязка «this» с помощью bind. Пример: bind: let boundFunc = func.bind(context); контекст не пропадёт</li>
                        <li class="blue">Частный this может жить только в FE/FD (внутри объектов включительно), глобальный this есть везде и он равен window</li>
                        <li class="red hidden">Частичное применение: let double = f.bind(null, 2); создаст копию функцию f, а 2 будет первым параметр функции double</li>
                        <li class="blue">Привязка А к контексту Б: let user = {name: "A"}; function f() {alert(this.name)} let fU = f.bind(user);</li>
                    </ul>
                    <p class="helpful" style="padding: 10px;">
                        <span>Задачи с собесов:</span><br>
                        <a href="https://jsfiddle.net/gzhel/phxmLsca/36/" target="_blank">(1-13)</a><br><br>
                        <span>Примеры кода:</span><br>
                        <a href="https://jsfiddle.net/gzhel/fuv846rs/75/" target="_blank">(примеры кода)</a><br><br>
                        <span>Задачи с собесов:</span><br>
                        <a href="https://jsfiddle.net/gzhel/jp15agL9/283/" target="_blank">(21-24)</a><br><br>
                        <span>Задачи с собесов:</span><br>
                        <a href="https://jsfiddle.net/gzhel/q1kha97g/69/" target="_blank">(25-29)</a><br><br>
                        <span>Задачи с собесов:</span><br>
                        <a href="https://jsfiddle.net/gzhel/984td7La/402/" target="_blank">(30-40)</a><br><br>
                        <span>Задачи с собесов:</span><br>
                        <a href="https://jsfiddle.net/gzhel/74gah389/109/" target="_blank">(41-48)</a>
                    </p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>7) Свойства объекта, их конфигурация</b>
                <hr>
                <div>
                    <input type="checkbox" name="7_1" id="7_1">
                    <label for="7_1">7.1 Флаги и дескрипторы свойств</label>
                    <p class="for-what">Зачем? Применяется в редких случаях, когда нужно запретить расширение, изменение объекта, неизменность данных.</p>
                    <ul>
                        <li class="green">Флаги свойств: объект имеет 3 доп. св-ва (разрешить/запретить): writable (запись), enumerable (циклы), configurable (delete)</li>
                        <li class="green">Как получить значения этих свойств у объекта? let descriptor = Object.getOwnPropertyDescriptor(obj, "propertyName");</li>
                        <li class="green">Как изменить значения этих свойств у объекта? Object.defineProperty(obj, "propertyName", {writable: false});</li>
                        <li class="blue">Глобальное запечатывание объекта: это методы, имеющие "готовые" комбинации флагов свойств. Пример: Object.freeze(obj)</li>
                        <li class="blue">Object.freeze(obj): запрещает добавлять/удалять/изменять свойства, устанавливает объекту configurable: false, writable: false</li>
                        <li class="green">Object.seal(obj): запрещает добавлять/удалять свойства, устанавливает объекту configurable: false</li>
                        <li class="blue">Object.getOwnPropertyDescriptors(obj): проверить флаги; Object.isFrozen(obj)/isSealed(obj): проверить на freeze/seal</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="7_2" id="7_2">
                    <label for="7_2">7.2 Свойства - геттеры и сеттеры (get, set)</label>
                    <p class="for-what">Зачем? Нужно для ограничений изменения объекта, либо для запрета чтения из объекта. Можем ввести пароль, если...</p>
                    <ul>
                        <li class="green">Свойства-аксессоры: используются для присвоения/получения значения, но во внешнем коде выглядят как св-ва объекта</li>
                        <li class="green">Синтаксис get: let obj = {get propName() {return this.propName;}, срабатывает, когда obj.propName читается}</li>
                        <li class="green">Синтаксис set: let obj = {set propName(val) {this.propName = val;}, срабатывает, когда obj.propName присваивается}</li>
                        <li class="blue">Если хотим запретить устанавливать короткое имя для ключа user, можем использовать set name для проверки</li>
                    </ul>
                    <p class="helpful" style="padding: 10px;">
                        <span>Примеры кода:</span><br>
                        <a href="https://jsfiddle.net/gzhel/nhdjf2p1/127/" target="_blank">(примеры кода)</a><br><br>
                        <span>Практика:</span><br>
                        <a href="https://jsfiddle.net/gzhel/fnxym9gz/25/" target="_blank">Добавить динамически getter к пустому объекту</a><br><br>
                        <span>Практика:</span><br>
                        <a href="https://jsfiddle.net/gzhel/aLpxju01/61/" target="_blank">Флаги и дескрипторы свойств</a>
                    </p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>8) Прототипы, наследование</b>
                <hr>
                <div>
                    <input type="checkbox" name="8_1" id="8_1">
                    <label for="8_1">8.1 Прототипное наследование</label>
                    <p class="for-what">Зачем? Например нужно слегка изменённый класс на основе базового, часто неявно используется в extends у классов</p>
                    <ul>
                        <li class="green">Скрытое свойство [[Prototype]]: равно либо null, либо ссылается на другой, родительский объект (класс)</li>
                        <li class="blue">Св-во __proto__: это геттер/сеттер для [[Prototype]]. Пример: animal = {eat:1}; cat = {meow:1}; rabbit.__proto__ = animal;</li>
                        <li class="violet">Св-во prototype: работает с классами, в prototype можно создавать новые поля (методы итд), расширять класс</li>
                        <li class="violet">Разница между __proto__ и prototype: первый может задать/посмотреть прототип, а второй может расширить прототип класса</li>
                        <li class="violet">Когда мы у экземпляра вызываем метод прототипа, он начинает искать его от "старших" прототипов иерархии к "младшим"</li>
                        <li class="red hidden">Прототипы и this: прототипы никак не влияют на this, при вызове метода this — всегда объект перед точкой</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="8_3" id="8_3">
                    <label for="8_3">8.3 Встроенные прототипы</label>
                    <p class="for-what">Зачем? Об этом говорилось в пункте 5.1, некоторые типы данных имеют объект-обёртку (наследуются от своих прототипов)</p>
                    <ul>
                        <li class="green">Object.prototype: содержит constructor (поля) и методы объекта, а также __proto__ того от чего он наследуется (или null)</li>
                        <li class="blue">Тип данных Object, откуда Array, Function? Object это прототип для Array, Function, Date. </li>
                        <li class="blue">Примитивы это не объекты: при попытке доступа к их свойствам, будет создан объект-обёртка, даст нам методы и исчезнет</li>
                    </ul>
                </div>
                <p class="helpful" style="padding: 10px;">
                    <span>Практика:</span><br>
                    <a href="https://jsfiddle.net/gzhel/htxndj8L/47/" target="_blank">Прототипы, наследование</a>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>9) Классы</b>
                <hr>
                <div>
                    <input type="checkbox" name="9_1" id="9_1">
                    <label for="9_1">9.1 Класс: базовый синтаксис</label>
                    <p class="for-what">Зачем? Классы это ES6+ замена функций конструкторов, причём намного более удобная. Классы используются много где в ООП JS</p>
                    <ul>
                        <li class="green">Синтаксис класса: class MyClass {constructor() {...} met1() {...} итд}; let user = new MyClass("Абоба")</li>
                        <li class="green">Что такое класс? Это функция, её код (поля) берётся из Class.prototype.constructor, а методы сохраняются в Class.prototype</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="9_2" id="9_2">
                    <label for="9_2">9.2 Наследование классов</label>
                    <p class="for-what">Зачем? По сути наследование это использование "родительских" полей и методов в дочернем классе, вот и весь ответ на вопрос</p>
                    <ul>
                        <li class="green">extends: ключевое слово для наследования полей и методов от другого класса. Пример: class Rabbit extends Animal {...}</li>
                        <li class="blue">[[Prototype]]: это поле класса, которое содержит prototype родительского класса, от которого он наследует методы и поля</li>
                        <li class="green">super(props): чтобы иметь доступ к родительским полям, нужно в дочернем constructor указать super(props)</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="9_3" id="9_3">
                    <label for="9_3">9.3 Статические свойства и методы</label>
                    <p class="for-what">Зачем? Небольшая приватность, защищённые поля внутри класса, не доступные извне</p>
                    <ul>
                        <li class="green">static: можем присвоить метод самой функции-классу, а не её "prototype", static methodName () {...}</li>
                        <li class="blue">static методы и "поля" будут доступны только самому классу, но не его экземплярам.</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="9_4" id="9_4">
                    <label for="9_4">9.4 Приватные и защищённые методы и свойства</label>
                    <p class="for-what">Зачем? Используется редко, но важно, если мы пишем класс или функцию, но при этом не хотим, чтобы к ним был доступ извне</p>
                    <ul>
                        <li class="blue">Защищённые свойства: начинаются с префикса _, становятся защищёнными при помощи get, set с условием</li>
                        <li class="green">Приватное свойство «#something»: начинаются с префикса #, добавляет поддержку приватных свойств и методов</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="9_6" id="9_6">
                    <label for="9_6">9.6 Проверка класса: "instanceof"</label>
                    <p class="for-what">Зачем? Позволяет узнать к какому Классу относится экземпляр класса, полезно использовать с if условиями, недооценённая вещь</p>
                    <ul>
                        <li class="green">instanceof: позволяет проверить, к какому классу принадлежит объект, возвращает true/false</li>
                        <li class="blue">instanceof работает с учётом населования, т.е. и на Raven и на Bird экземпляр класса Raven вернёт true</li>
                    </ul>
                </div>
                <div>
                    <p class="helpful" style="padding: 10px;">
                        <span>Практика:</span><br>
                        <a href="https://jsfiddle.net/gzhel/nx7e5o0r/83/" target="_blank">Работа с классами</a>
                    </p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>10) Обработка ошибок</b>
                <hr>
                <div>
                    <input type="checkbox" name="10_1" id="10_1">
                    <label for="10_1">10.1 Обработка ошибок, "try..catch"</label>
                    <p class="for-what">Зачем? Создано исключительно для обработки ошибок при не выполнении строк кода, запросов на API и так далее</p>
                    <ul>
                        <li class="green">Синтаксис «try…catch»: если код в try поймал ошибку, мы переходим в блок catch, который ловит и обрабатывает ошибку</li>
                        <li class="blue">Ошибка, которая попадает в catch содержит поля: name (имя), message (детали), stack (стек вызова)</li>
                        <li class="green">try…catch…finally: finally выполняется всегда, после try, если не было ошибок, после catch, если ошибки были</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="10_2" id="10_2">
                    <label for="10_2">10.2 Пользовательские ошибки, расширение Error</label>
                    <p class="for-what">Зачем? Мы можем обработать ошибку из catch как угодно: вызвать нотификацию с сообщением ошибки, вывести ошбику в поля ввода</p>
                    <ul>
                        <li class="blue">Расширение Error: создаём класс на основе Error, спрашиваем instanceof и предпринимаем какие-либо действия</li>
                    </ul>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>11) Промисы, async/await</b>
                <hr>
                <div>
                    <input type="checkbox" name="11_1" id="11_1">
                    <label for="11_1">11.1 Введение: колбэки</label>
                    <p class="for-what">Зачем? Грубо говоря, это функция в качестве параметра функции, которую можно вызвать когда нам будет нужно</p>
                    <ul>
                        <li class="green">callback: мы передаём callback-функцию как параметр функции, и можем вызвать callback функцию по нужному нам условию</li>
                        <li class="red hidden">Пример коллбека: загрузка скрипта, на script.onload что-то одно бросаем в коллбек, на script.onerror что-то другое</li>
                        <li class="red hidden"> Ад коллбеков: если нужно загрузить N данных один за другим, нужно изолировать действия по разным функциям</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="11_2" id="11_2">
                    <label for="11_2">11.2 Промисы</label>
                    <p class="for-what">Зачем? Промисы гарантируют, что обработка данных произойдёт после успешной их загрузки, например при обращении к API</p>
                    <ul>
                        <li class="green">Синтаксис: let promise = new Promise(function(resolve, reject) {// функция-исполнитель, executor});</li>
                        <li class="green">resolve(value): это параметр колбэк-функции в Promise, если промис успешен, передаст значение value в .then</li>
                        <li class="green">reject(error): это параметр колбэк-функции в Promise, если промис поймал ошибку, передаст значение error в .catch</li>
                        <li class="green">Методы Promise (.then): .then((value) => {}), выполнится когда промис передаст значение value в resolve</li>
                        <li class="green">Методы Promise (.catch): .catch((error) => {}), выполнится когда промис передаст значение error в reject</li>
                        <li class="blue">Методы Promise (.finally): .finally(() => {}), выполнится в конце, в любом случае, полезен для очистки состояний</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="11_3" id="11_3">
                    <label for="11_3">11.3 Цепочка промисов</label>
                    <p class="for-what">Зачем? Применяется редко, позволяют дополнительно обработать данные полученные после первого .then</p>
                    <ul>
                        <li class="blue">.then можно использовать не один раз, а много, т.к. они возвращают промисы: .then.catch.then.then итд</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="11_5" id="11_5">
                    <label for="11_5">11.5 Promise API</label>
                    <p class="for-what">Зачем? Методы позволяют дождаться выполнения всех промисов, либо быстрейшего промиса, а уже после делать какую-то обработку</p>
                    <ul>
                        <li class="blue">Promise.all([prom1, prom2, ...]): принимает массив промисов, ждёт выполнения всех, возвращает массив с результатами</li>
                        <li class="blue">Promise.race([prom1, prom2, ...]): принимает массив промисов, ждёт выполнения быстрейшего, возвращает его как результат</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="11_8" id="11_8">
                    <label for="11_8">11.8 Async/await</label>
                    <p class="for-what">Зачем? Позволяет писать код, который выглядит как синхронный, но используется для решения асинхронных задач, заменяет .then</p>
                    <ul>
                        <li class="green">Ключевое слово async: ставится перед параметрами функции, позволяет использовать функции ключевое слово await</li>
                        <li class="green">Ключевое слово await: говорит JS ждать пока промис справа от не выполнится. Пример: let value = await promise;</li>
                        <li class="blue">Принято оборачивать часть с await в try {}, если мы поймаем ошибку, она попадёт в catch(err) {} и будет обработана</li>
                    </ul>
                </div>
                <div>
                    <p class="helpful" style="padding: 10px;">
                        <span>Примеры кода:</span><br>
                        <a href="https://jsfiddle.net/gzhel/fzgupj9w/118/" target="_blank">(примеры кода)</a><br><br>
                        <span>Задачи с собесов (промисы)</span><br>
                        <a href="https://jsfiddle.net/gzhel/w6sn491z/209/" target="_blank">(14-20)</a>
                    </p>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>12) Генераторы, продвинутая итерация</b>
                <hr>
                <div>
                    <input type="checkbox" name="12_1" id="12_1">
                    <label for="12_1">12.1 Генераторы</label>
                    <p class="for-what">Зачем? Мы порционно выдаём результат, yield это что-то вроде точек останова, но на уровне выполнения кода</p>
                    <ul>
                        <li class="green">Функция-генератор: это функция, которая могут "последовательно" выдавать результат её работы</li>
                        <li class="green">Синтаксис: function* {yield 1; yield 2;return 3}, эта функция не выполняет код, а ждёт команд</li>
                        <li class="blue">FG имеет метод next(): возвр. объект с ключами value и done для первого yield, след. str.next() вернёт рез. для след. yield</li>
                        <li class="violet">У каждой итерируемой структуры есть Symbol.iterator, который позволяет итерировать эту структуру</li>
                        <li class="violet">У обычной функции нет Symbol.iterator, но у функций-генераторов, он есть, т.е. такие функции итерируемые</li>
                        <li class="violet">Чем отличается yield от await? Почти ничем, но FG имеет метод next(), который позволяет смотреть выполнение поэтапно</li>
                    </ul>
                </div>
                <div class="hidden">
                    <input type="checkbox" name="11_2" id="11_2">
                    <label for="11_2">12.2 Асинхронные итераторы и генераторы</label>
                    <p class="for-what">Зачем? ...</p>
                    <ul>
                        <li class="red hidden">Подходит для выполнения сетевых запросов (можем использовать async/await с try catch внутри)</li>
                    </ul>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>13) Модули</b>
                <hr>
                <div>
                    <input type="checkbox" name="13_1" id="13_1">
                    <label for="13_1">13.1 Модули, введение</label>
                    <p class="for-what">Зачем? Улучшает переиспользование, декомпозирует код, да и вообще это лучшее что было добавлено в JS</p>
                    <ul>
                        <li class="blue">Модуль: это просто файл, который по умолчанию в "use strict", в JS один скрипт – это один модуль</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="13_2" id="13_2">
                    <label for="13_2">13.2.1 Экспорт модуля</label>
                    <p class="for-what">Зачем? Позволяет использовать код во многих других местах, да и вообще, что за вопросы?!</p>
                    <ul>
                        <li class="green">export модуля: делает переменные и функции модуля потенциально доступными для других модулей, при наличии у них импорта</li>
                        <li class="green">Экспорт перед объявлением класса/функции/итд: export [default]/name class/function/variable/итд</li>
                        <li class="blue">Реэкспорт: для отдельного файла экспортов, импорт из другого файла и сразу экспорт: export {sayHi} from './say.js';</li>
                    </ul>
                </div>
                <div>
                    <input type="checkbox" name="13_2" id="13_2">
                    <label for="13_2">13.2.2 Импорт модуля</label>
                    <p class="for-what">Зачем? Позволяет использовать код откуда-то оттуда прямо вот куда-то сюда</p>
                    <ul>
                        <li class="green">import модуля: позволяет брать переменные и функции из других модулей, при наличии экспорта у тех модулей</li>
                        <li class="blue">Именованный импорт: самый популярный и предпочитаемый вариант. Пример: import {x [as y], ...} from "module";</li>
                        <li class="green">Импорт по умолчанию: для export default, можем дать любое имя. Пример: import x from "module";</li>
                        <li class="green">Импорт всего модуля: даёт использовать все импорты модуля, не желателен. Пример: import * as obj from "module";</li>
                        <li class="blue">Подключение модуля стилей: позволяет модулю понимать стили классов. Пример: import "./styles.css";</li>
                    </ul>
                </div>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <div class="text" style="background-color: white;">
                <b>14) Разное</b>
                <hr>
                <div>
                    <input type="checkbox" name="14_3" id="14_3">
                    <label for="14_3">14.1 Proxy и Reflect</label>
                    <p class="for-what">Зачем? Позволяет ставить на объект/функцию/класс различные ловушки и кастомизировать их ответы на эти ловушки</p>
                    <ul>
                        <li class="green">Proxy: это обёртка вокруг объекта/функции/класса, которая ставит "ловушки" на взаимодействие с ним</li>
                        <li class="green">Синтаксис: let proxy = new Proxy(target - исходный объект, handler - объект методов "ловушек")</li>
                        <li class="blue">Методы у прокси объекта по сути копируют базовый функционал работы с объектом (чтение итд), но могут его расширить</li>
                        <li class="green">Методы для объекта: get (obj, key), set (obj, key, value), has (obj, key), deleteProperty (obj, key)</li>
                        <li class="green">Методы для функций: apply (func, _this, args) // сработает когда данная функция будет вызываться</li>
                        <li class="green">Методы для классов: construct (class, args) // сработает при создании экземпляра класса через new</li>
                        <li class="blue">Можно создать "ловушку" на кастомные методы, на любые, расширяя функционал стандартных взаимодействий (см. пример ниже)</li>
                    </ul>
                    <p class="helpful" style="padding: 10px;">
                        <span>Практика:</span><br>
                        <a href="https://jsfiddle.net/gzhel/31vfomgt/163/" target="_blank"> Proxy</a>
                    </p>
                </div>
                <div>
                    <input type="checkbox" name="14_3" id="14_3">
                    <label for="14_3">14.3 Каррирование</label>
                    <p class="for-what">Зачем? Благодаря этому, можно применять функции частично, например из одной функции сделать несколько со своим выполнением</p>
                    <ul>
                        <li class="green">Каррирование: это трансформация функций так, чтобы они принимали аргументы и так f(a, b, c), и так f(a)(b)(c)</li>
                        <li class="blue">Алгоритм каррирования: f(a, b) { b ? return обычная функция : return функция с карированием}</li>
                        <li class="green">Велосипед изобретать необязательно: есть функция lodash _.curry(f), которая делает каррирование функции за нас</li>
                    </ul>
                </div>
            </div>
        </section>
    </div>
    <script>
        const showReds = document.querySelector("#show_reds");
        const hideReds = document.querySelector("#hide_reds");
        const reds = document.querySelectorAll('.hidden');
        showReds.addEventListener('click', () => reds.forEach(red => red.tagName === "LI"? red.style.display = 'list-item' : red.style.display = 'block'));
        hideReds.addEventListener('click', () => reds.forEach(red => red.style.display = 'none'));

        const hideForWhat = document.querySelector("#hide_for_what");
        const forWhat = document.querySelectorAll(".for-what");
        hideForWhat.addEventListener('click', () => forWhat.forEach(el => el.style.display = 'none'));

        const hidePractise = document.querySelector("#hide_practise");
        const practise = document.querySelectorAll(".helpful");
        hidePractise.addEventListener('click', () => practise.forEach(el => el.style.display = 'none'));
    </script>
</body>
</html>