<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css">
    <link rel="stylesheet" href="../../styles.css">
    <title>Продвинутая работа с функциями</title>
</head>
<body>
    <div class="learn-page__layout">
        <h1><a href="../../1_module/">Back to module 1</a></h1>
        <section class="learn-page__layout--study-block">
            <h3>Обозначения:</h3>
            <div class="text checked">Зеленый блок = прогресс изучения; Зеленая рамка = повторил, классно.</div>
            <div class="help helpful">Синий блок = полезная подсказка; Синяя рамка = очень важно, очень классно.</div>
            <div class="script useless">Красный блок = задача; Красная рамка = на мой взгляд не стоит внимания.</div>
        </section>
        <section class="learn-page__layout--study-block helpful">
            <h3>6.1 Рекурсия и стек</h3>
            <div class="text">
                <b>Два способа мышления</b>
                <p>
                    Рекурсия – это когда функция вызывает сама себя. <br><br>
                    Пример рекурсивной функции: function pow(x, n) {if (n == 1) {return x;} else {return x * pow(x, n - 1);}}<br></br>
                    В примере выше можно заметить if else, тут if служит моментом выхода из рекурсии, когда значение получено. <br><br>
                    Рекурсивное решение задачи обычно короче, чем итеративное. Можно писать рекурсию через стрелочные функции. <br><br>
                    Рекурсивные функции могут быть использованы для элегантного решения определённых задач.
                </p>
            </div>
            <div class="text">
                <b>Контекст выполнения, стек</b>
                <p>
                    Информация о процессе выполнения запущенной функции хранится в её контексте выполнения. <br><br>
                    Грубо говоря, контекст - это данные в некоторый момент исполнения функции. <br><br>
                    Когда функция производит вложенный вызов, происходит следующее:<br></br>
                    1) Выполнение текущей функции приостанавливается. <br><br>
                    2) Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения. <br><br>
                    3) Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения. <br><br>
                    4) После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена. <br><br><br>
                    Для функции function pow(x, n) {if (n == 1) {return x;} else {return x * pow(x, n - 1);}} контекст pow(2, 3) можно описать так: <br><br>
                    { x: 2, n: 3, строка 5 } -> { x: 2, n: 2, строка 1 } -> { x: 2, n: 1, строка 1 } -> функция завершается, возвращает 2. <br><br>
                    Далее функция закончилась, контекст { x: 2, n: 1, строка 1 } удаляется, на верхушке стека { x: 2, n: 2, строка 1 } возвращает 4,
                    после оно тоже удаляется, на верхушке { x: 2, n: 3, строка 5 } возвращает 8. Глубина рекурсии 3 (стоит помнить что это стек).<br></br>
                    Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.
                </p>
            </div>
            <div class="text">
                <b>Рекурсивные обходы</b>
                <p>
                    Например, у нас есть компания, в компании есть отделы, а там подотделы, а там подразделения, 
                    и в этой вложенности у сотрудников есть зп. Как её посчитать? Рекурсивно, итеративно не выйдет.
                </p>
                <img src="./img/1.png" alt="" width="100%">
            </div>
            <div class="text">
                <b>Связанный список</b>
                <p>
                    Для чего? Например упорядоченный список объектов (массив не подходит из-за медленной вставки/удаления). <br><br>
                    Элемент связанного списка определяется рекурсивно как объект с: value, next – свойство, 
                    ссылающееся на следующий элемент связанного списка или null, если это последний элемент. <br></br>
                    Пример: let list = { value: 1 }; list.next = { value: 2 }; list.next.next = { value: 3 }; list.next.next.next = { value: 4 }; <br><br>
                    1) Список можно легко разделить на несколько частей: let secondList = list.next.next; list.next.next = null; <br><br>
                    2) И впоследствии объединить обратно: list.next.next = secondList; <br><br>
                    3) Для добавления нового элемента, нужно обновить первый элемент списка: list = { value: "new item", next: list }; <br><br>
                    4) Чтобы удалить элемент из середины списка, нужно изменить значение next предыдущего элемента: list.next = list.next.next; <br><br>
                    Главным недостатком является то, что мы не можем легко получить доступ к элементу по его индексу. 
                    В простом массиве: arr[n] является прямой ссылкой. Но в списке мы должны начать с первого элемента и перейти в next N раз, чтобы получить N-й элемент.
                </p>
            </div>
            <div class="script">
                <b>Задачи. Вычислить сумму чисел до данного</b>
                <p>
                    <code>
                        function sumTo(n) {
                            let sum = 0;
                            for (let i = 1; i &lt;= n; i++) {
                                sum += i;
                            }
                            return sum;
                        }
                    </code>
                </p>
                <p>
                    <code>
                        function sumTo(n) {
                            if (n === 1) {
                                return 1;
                            }
                            return n + sumTo(n - 1);
                        }
                    </code>
                </p>
                <p>
                    <code>
                        // sumTo(n) = n*(n+1)/2 <br><br>
                        function sumTo(n) {
                            return n * (n + 1) / 2;
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Вычислить факториал</b>
                <p>
                    <code>
                        function factorial(n) {
                            return (n !== 1) ? factorial(n - 1) : 1;
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Числа Фибоначчи</b>
                <p>
                    <code>
                        function fib(n) {
                            return (n &lt;= 1) ? n : (fib(n - 1) + fib(n + 1));
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Вывод односвязного списка</b>
                <p>
                    <code>
                        function printList(list) {
                            while(list) {
                                alert(list.value);
                                list = list.next;
                            }
                        }
                    </code>
                </p>
                <p>
                    <code>
                        function printList(list) {
                            alert(list.value);
                            if (list.next) {
                                printList(list.next);
                            }
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Вывод односвязного списка</b>
                <p>
                    <code>
                        ???
                    </code>
                </p>
                <p>
                    <code>
                        function printReverseList(list) {
                            if (list.next) {
                                printReverseList(list.next);
                            }
                            alert(list.value);
                        }
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>6.2 Остаточные параметры и оператор расширения</h3>
            <div class="text">
                <b>Остаточные параметры (...)</b>
                <p>
                    Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена.<br><br>
                    Лишние аргументы не вызовут ошибку, но посчитаются только те, которые являются параметрами функции.<br></br>
                    Остаточные параметры означают: «собери оставшиеся параметры и положи их в массив»: function sumAll(...args) {...}<br><br>
                    Важно помнить, что остаточные парамтеры запишутся в массив args. <br><br>
                    Остаточные параметры должны располагаться в конце.
                </p>
            </div>
            <div class="text">
                <b>Переменная "arguments"</b>
                <p>
                    Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.<br><br>
                    Раньше не было остаточных параметров, и получить все аргументы функции можно было только с помощью arguments. <br><br>
                    Для более удобной работы с аргументами лучше использовать остаточные параметры. <br><br>
                    Стрелочные функции не имеют "arguments". Если мы обратимся к arguments из стрелочной функции, то получим аргументы внешней «нормальной» функции.
                </p>
            </div>
            <div class="text">
                <b>Оператор расширения</b>
                <p>
                    Он похож на остаточные параметры – тоже использует ..., но делает совершенно противоположное.<br><br>
                    Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов. <br><br>
                    Пример: let arr1 = [1, -2, 3, 4]; let arr2 = [8, 3, -8, 1]; alert( Math.max(...arr1, ...arr2) ); // 8 <br><br>
                    Оператор расширения можно использовать для слияния массивов: let arr = [3, 5, 1]; let arr2 = [8, 9, 15]; let merged = [0, ...arr, 2, ...arr2]; <br><br>
                    Оператор расширения работает только с итерируемыми объектами. Если нужно сделать из чего угодно массив, то Array.from — более универсальный метод.
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block helpful">
            <h3>6.3 Замыкание</h3>
            <div class="text">
                <b>Лексическое Окружение</b>
                <p>
                    В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, 
                    называемый лексическим окружением LexicalEnvironment, который состоит из двух частей: <br><br>
                    1) Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this). <br><br>
                    2) Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок). <br><br><br>
                    "Переменная" – это просто свойство специального внутреннего объекта: Environment Record. 
                    «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта». <br><br>
                    Переменная – это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом. <br><br>
                    Работа с переменными – это на самом деле работа со свойствами этого объекта.
                </p>
            </div>
            <div class="help">
                <b>Function Declaration</b>
                <p>
                    В отличие от переменных, объявленных с помощью let, они полностью инициализируются не тогда, 
                    когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение. <br><br>
                    Для верхнеуровневых функций это означает момент, когда скрипт начинает выполнение 
                    (Вот почему мы можем вызвать функцию, объявленную через Function Declaration, до того, как она определена):
                </p>
                <img src="./img/2.png" alt="" width="100%">
            </div>
            <div class="text">
                <b>Внутреннее и внешнее лексическое окружение</b>
                <p>
                    При запуске функции для неё автоматически создаётся новое лексическое окружение, для хранения локальных переменных и параметров вызова. <br><br>
                    В процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции) и внешнее (глобальное). <br><br>
                    Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, 
                    затем в следующем и так далее, до глобального. Если переменная не была найдена, это будет ошибкой в strict mode. Без strict mode, 
                    для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем. <br><br>
                    Функция получает текущее значение внешних переменных, то есть, их последнее значение: <br><br>
                    Старые значения переменных нигде не сохраняются. Когда функция хочет получить доступ к переменной, 
                    она берёт её текущее значение из своего или внешнего лексического окружения.
                </p>
                <img src="./img/3.png" alt="" width="100%">
            </div>
            <div class="help">
                <b>Один вызов – одно лексическое окружение</b>
                <p>
                    Новое лексическое окружение функции создаётся каждый раз, когда функция выполняется. <br><br>
                    Если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, 
                    со своими, специфичными для этого вызова, локальными переменными и параметрами.
                </p>
            </div>
            <div class="text">
                <b>Вложенные функции</b>
                <p>
                    Функция называется «вложенной», когда она создаётся внутри другой функции. <br><br>
                    В JavaScript вложенные функции используются очень часто. <br><br>
                    Пример вложенной функции:
                </p>
                <img src="./img/4.png" alt="" width="100%">
                <p>
                    Когда внутренняя функция начинает выполняться, начинается поиск переменной count++ изнутри-наружу: <br><br>
                    Локальные переменные вложенной функции… Переменные внешней функции… И так далее, пока не будут достигнуты глобальные переменные. <br><br>
                    1) Сбросить счётчик внутри функции мы не можем. Мы не можем получить к ней доступ извне. <br><br>
                    2) Для каждого вызова функции создаётся новое лекс. окружение: let fn1 = funcName(); let fn2 = funcName(); - независимы друг от друга.
                </p>
            </div>
            <div class="text">
                <b>Окружение в деталях</b>
                <p>
                    1) Когда скрипт только начинает выполняться, есть только глобальное лексическое окружение <br><br>
                    Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были созданы.
                </p>
                <img src="./img/5.png" alt="" width="100%">
                <p>
                    2) Код продолжает выполняться, объявляется новая глобальная переменная counter, которой присваивается результат вызова makeCounter.
                    В момент вызова makeCounter() создаётся лексическое окружение, для хранения его переменных и аргументов.
                </p>
                <img src="./img/6.png" alt="" width="100%">
                <p>
                    3) В процессе выполнения makeCounter() создаётся небольшая вложенная функция. Не имеет значения, какой способ объявления функции используется: 
                    Function Declaration или Function Expression. Все функции получают свойство [[Environment]], которое ссылается на лексическое окружение, 
                    в котором они были созданы. <br><br>
                    На этом шаге внутренняя функция была создана, но ещё не вызвана. Код внутри function() { return count++ } не выполняется.
                </p>
                <img src="./img/7.png" alt="" width="100%">
                <p>
                    4) Выполнение продолжается, вызов makeCounter() завершается, и результат (небольшая вложенная функция) присваивается глобальной переменной counter. <br><br>
                    В этой функции есть только одна строчка: return count++, которая будет выполнена, когда мы вызовем функцию.
                </p>
                <img src="./img/8.png" alt="" width="100%">
                <p>
                    5) При вызове counter() для этого вызова создаётся новое лексическое окружение. Оно пустое, так как в самом counter локальных переменных нет. 
                    Но [[Environment]] counter используется, как ссылка на внешнее лексическое окружение outer, 
                    которое даёт доступ к переменным предшествующего вызова makeCounter, где counter был создан. <br><br>
                    Теперь, когда вызов ищет переменную count, он сначала ищет в собственном лексическом окружении (пустое), 
                    а затем в лексическом окружении предшествующего вызова makeCounter(), где и находит её. <br><br>
                    В большинстве случаев, объект лексического окружения существует до того момента, пока есть функция, которая может его использовать. 
                </p>
                <img src="./img/9.png" alt="" width="100%">
                <p>
                    6) Вызов counter() не только возвращает значение count, но также увеличивает его. Обратите внимание, 
                    что модификация происходит «на месте». Значение count изменяется конкретно в том окружении, где оно было найдено. <br><br>
                    Следующие вызовы counter() сделают то же самое.
                </p>
                <img src="./img/10.png" alt="" width="100%">
                <p>
                    Ответ на второй вопрос из начала главы: <br><br>
                    Функция work() в коде ниже получает name из того места, где была создана, через ссылку на внешнее лексическое окружение: <br><br>
                    Так что, результатом будет "Pete". Но, если бы в makeWorker() не было let name, тогда бы поиск продолжился дальше и была бы взята глобальная переменная.
                </p>
                <img src="./img/11.png" alt="" width="100%">
            </div>
            <div class="help">
                <b>Замыкания</b>
                <p>
                    Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. <br><br>
                    То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] 
                    и все они могут получить доступ к внешним переменным.
                </p>
            </div>
            <div class="text">
                <b>Блоки кода и циклы</b>
                <p>
                    Предыдущие примеры сосредоточены на функциях. Но лексическое окружение существует для любых блоков кода {...}. <br><br>
                    Лексическое окружение создаётся при выполнении блока кода и содержит локальные переменные для этого блока. <br><br>
                    1) If: В следующем примере переменная user существует только в блоке if (а phrase берётся из ссылки на внешнее окружение):
                </p>
                <img src="./img/12.png" alt="" width="100%">
                <p>
                    2) For, while: Для цикла у каждой итерации своё отдельное лексическое окружение. Если переменная объявлена в for(let ...), то она также в нём. <br><br>
                    for (let i = 0; i &lt; 10; i++) {...} alert(i); // Ошибка, нет такой переменной <br><br>
                    let i визуально находится снаружи {...}. Но конструкция for – особенная в этом смысле, 
                    у каждой итерации цикла своё собственное лексическое окружение с текущим i в нём. <br><br>
                    3) Блоки кода: Мы также можем использовать «простые» блоки кода {...}, чтобы изолировать переменные в «локальной области видимости»: <br><br>
                    {let message = "Hello"; alert(message); // Hello} alert(message); // Ошибка: переменная message не определена
                </p>
            </div>
            <div class="help">
                <b>IIFE</b>
                <p>
                    «immediately-invoked function expressions» (аббревиатура IIFE), что означает функцию, запускаемую сразу после объявления. <br><br>
                    Это не то, что мы должны использовать сегодня, но, полезно понимать принцип работы. <br><br>
                    Синтаксис: (function() {let message = "Hello";alert(message);})(); <br><br>
                    Стоит обратить внимание, что это работает только с анонимными функциями.
                </p>
            </div>
            <div class="script">
                <b>Задачи. Независимы ли счётчики?</b>
                <p>
                    <code>
                        Независимы. Покажет 0, 1.
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Объект счётчика</b>
                <p>
                    <code>
                        // Одно лексическое окружение, имеют доступ к count <br><br>
                        counter.up() // 1 <br><br>
                        counter.up() // 2 <br><br>
                        counter.down() // 1
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Функция в if</b>
                <p>
                    <code>
                        // ошибка, т.к. sayHi объявлена внутри if, существует только внутри этого блока {}
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Сумма с помощью замыканий</b>
                <p>
                    <code>
                        function sum(a) {
                            return function(b) {
                                return a + b;
                            }
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Фильтрация с помощью функции</b>
                <p>
                    <code>
                        function inBetween(a, b) {
                            return function(x) {
                                return (x >= a && x &lt;= b); 
                            }
                        }
                        // filter вызывается много раз для каждого элемента массива, где х - это каждый элемент массива
                    </code>
                </p>
                <p>
                    <code>
                        function inArray(arr) {
                            return function(x) {
                                return arr.includes(x);
                            }
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Сортировать по полю</b>
                <p>
                    <code>
                        function byField(fieldName) {
                            return function(a, b) {
                                return (a[fieldName] > b[fieldName]) ? 1 : -1;
                            }
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Армия функций</b>
                <p>
                    <code>
                        ???
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>6.4 Устаревшее ключевое слово "var"</h3>
            <div class="text">
                <b>Для «var» не существует блочной области видимости</b>
                <p>
                    Область видимости переменных var ограничивается либо функцией, либо, если переменная глобальная, 
                    то скриптом. Такие переменные доступны за пределами блока {...}. Пример: <br><br>
                    if (true) {var test = true;} alert(test); // true
                </p>
            </div>
            <div class="text">
                <b>«var» обрабатываются в начале запуска функции</b>
                <p>
                    Т.е. код 1 эквивалентен коду 2: <br><br>
                    1) function sayHi() {phrase = "Привет";alert(phrase);var phrase;} <br><br>
                    2) function sayHi() {var phrase;phrase = "Привет";alert(phrase);} <br><br>
                    Объявления переменных «всплывают», но присваивания значений – нет. Т.е. код 3 эквивалентен коду 4:<br><br>
                    3) function sayHi() {alert(phrase);var phrase = "Привет";} <br><br>
                    4) function sayHi() {var phrase;alert(phrase);phrase = "Привет";} // undefined
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>6.5 Глобальный объект</h3>
            <div class="text">
                <b>Основы</b>
                <p>
                    Глобальный объект предоставляет переменные и функции, доступные в любом месте программы.<br><br>
                    В браузере он называется window, в Node.js — global. <br><br>
                    Ко всем свойствам глобального объекта можно обращаться напрямую: alert("Привет"); то же самое, что и window.alert("Привет"); <br><br>
                    Обычно не рекомендуется использовать глобальные переменные.
                </p>
            </div>
            <div class="text">
                <b>Использование для полифилов</b>
                <p>
                    Глобальный объект можно использовать, чтобы проверить поддержку современных возможностей языка.<br><br>
                    Например, проверить наличие встроенного объекта Promise: if (!window.Promise) {alert("Ваш браузер очень старый!");} <br><br>
                    Если нет (скажем, используется старый браузер), мы можем создать полифил: добавить функции, 
                    которые не поддерживаются окружением, но существуют в современном стандарте. window.Promise = ... // собственная реализация современной возможности языка
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>6.6 Объект функции, NFE</h3>
            <div class="text">
                <b>Основы</b>
                <p>
                    В JavaScript функции – это объекты. «объект, который может делать какое-то действие»<br><br>
                    Функции можно не только вызывать, но и использовать их как обычные объекты: добавлять/удалять свойства, передавать их по ссылке и т.д.
                </p>
            </div>
            <div class="help">
                <b>Свойство «name»</b>
                <p>
                    Имя функции нам доступно как свойство «name»: alert(sayHi.name); // sayHi
                </p>
            </div>
            <div class="help">
                <b>Свойство «length»</b>
                <p>
                    Содержит количество параметров функции в её объявлении. <br><br>
                    function f1(a) {} function f2(a, b) {} function many(a, b, ...more) {} <br><br>
                    alert(f1.length); // 1 alert(f2.length); // 2 alert(many.length); // 2
                </p>
            </div>
            <div class="help">
                <b>Пользовательские свойства</b>
                <p>
                    Мы также можем добавить свои собственные свойства.
                </p>
            </div>
            <div class="text">
                <b>Named Function Expression</b>
                <p>
                    NFE – это термин для Function Expression, у которого есть имя.<br><br>
                    Пример: let sayHi = function <b>func</b>(who) {...} <br><br>
                    А зачем имя func? 1) позволяет функции ссылаться на себя же; 2) не доступно за пределами функции. <br><br>
                    Например, ниже функция sayHi вызывает себя с "Guest", если не передан параметр who:
                </p>
                <img src="./img/13.png" alt="" width="100%">
                <p>
                    Почему не сделаем так: else {sayHi("Guest");} ? <br><br>
                    Потому что если переопределим sayHi, получим ошибку: sayHi берётся из внешнего лексического окружения 
                    (т.к. локальная отсутствует), и если зададим ей null, то на "последний" момент вызова она будет равна null. <br></br>
                    "func" локальное и находится внутри функции. Теперь оно взято не снаружи (и недоступно оттуда). 
                    Спецификация гарантирует, что оно всегда будет ссылаться на текущую функцию. <br></br>
                    Трюк с «внутренним» именем, описанный выше, работает только для Function Expression и не работает для Function Declaration.
                </p>
            </div>
            <div class="script">
                <b>Задачи. Установка и уменьшение значения счётчика</b>
                <p>
                    <code>
                        function makeCounter() {
                            let count = 0;
                            function counter() {
                                return count++;
                            }
                            counter.set = function(val) {
                                count = value;
                            }
                            counter.decrease = function() {
                                count--;
                            }

                            return counter;
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Сумма с произвольным количеством скобок</b>
                <p>
                    <code>
                        function sum(a) {
                            let currSum = a;
                            function f(b) {
                                currSum += b;
                                return f;
                            }
                            f.toString = function() {
                                return currSum;
                            }
                            return next;
                        }
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>6.7 Синтаксис "new Function"</h3>
            <div class="text">
                <b>Синтаксис</b>
                <p>
                    Существует ещё один вариант объявлять функции. Он используется крайне редко.<br><br>
                    let func = new Function([arg1, arg2, ...argN], functionBody);
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block helpful">
            <h3>6.8 Планирование: setTimeout и setInterval</h3>
            <div class="text">
                <b>Основы</b>
                <p>
                    Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».<br><br>
                    1) setTimeout позволяет вызвать функцию один раз через определённый интервал времени. <br><br>
                    2) setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
                </p>
            </div>
            <div class="text">
                <b>setTimeout</b>
                <p>
                    Синтаксис: let timerId = setTimeout(func, [delay], [arg1], [arg2], ...)<br><br>
                    1) func: Функция или строка кода для выполнения. Обычно это функция. <br><br>
                    2) delay: Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0. <br><br>
                    3) arg1, arg2: Аргументы, передаваемые в функцию. <br><br>
                    Пример (код вызывает sayHi() спустя одну секунду): setTimeout(sayHi, 1000); <br><br>
                    Передавайте функцию, но не запускайте её. Так - неправильно: setTimeout(sayHi(), 1000);
                </p>
            </div>
            <div class="help">
                <b>Отмена через clearTimeout</b>
                <p>
                    Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.<br><br>
                    Синтаксис для отмены: let timerId = setTimeout(...); clearTimeout(timerId);
                </p>
            </div>
            <div class="text">
                <b>Рекурсивный setTimeout</b>
                <p>
                    Есть два способа запускать что-то регулярно: setInterval и рекурсивный setTimeout. Пример:
                </p>
                <img src="./img/14.png" alt="" width="100%">
                <p>
                    Рекурсивный setTimeout позволяет задать задержку между выполнениями более точно, чем setInterval.
                </p>
            </div>
            <div class="text">
                <b>setTimeout с нулевой задержкой</b>
                <p>
                    Особый вариант использования: setTimeout(func, 0) или просто setTimeout(func). <br><br>
                    Это планирует вызов func настолько быстро, насколько это возможно. Но планировщик будет 
                    вызывать функцию только после завершения выполнения текущего кода. Так вызов функции 
                    будет запланирован сразу после выполнения текущего кода. <br></br>
                    Пример: setTimeout(() => alert("Мир")); alert("Привет"); <br></br>
                    Первая строка помещает вызов в «календарь» через 0 мс. 
                    Но планировщик проверит «календарь» только после того, как текущий код завершится. 
                    Поэтому "Привет" выводится первым, а "Мир" – после него.
                </p>
            </div>
            <div class="script">
                <b>Задачи. Вывод каждую секунду</b>
                <p>
                    <code>
                        function printNumbers(from, to) {
                            let current = from;
                            let timerId = setInterval(function() {
                                alert(current);
                                if (current === to) clearInterval(timerId);
                                current++;
                            }, 1000);
                        }
                    </code>
                </p>
                <p>
                    <code>
                        function printNumbers(from, to) {
                            let current = from;
                            let timerId = setTimeout(function tick() {
                                alert(current);
                                if (current &lt; to) setTimeout(tick, 1000);
                                current++;
                            }, 1000);
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Что покажет setTimeout?</b>
                <p>
                    <code>
                        1. Объявился i; <br><br>
                        2. setTimeout зашёл в стек <br><br>
                        3. for зашёл в стек <br><br>
                        Ответ: 100000000 // setTimeout ждёт пока for выйдет из стека
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>6.9 Декораторы и переадресация вызова, call/apply</h3>
            <div class="text">
                <b>Прозрачное кеширование</b>
                <p>
                    Представим, что у нас есть функция slow(x), выполняющая ресурсоёмкие вычисления, но возвращающая стабильные результаты. <br><br>
                    Если функция вызывается часто, то, вероятно, мы захотим кешировать (запоминать) возвращаемые ею результаты, 
                    чтобы сэкономить время на повторных вычислениях. <br><br>
                    Вместо того, чтобы усложнять slow(x) дополнительной функциональностью, мы заключим её в функцию-обёртку – «wrapper», которая добавит кеширование.
                </p>
                <img src="./img/15.png" alt="" width="100%">
                <p>
                    С точки зрения внешнего кода, обёрнутая функция slow по-прежнему делает то же самое. Обёртка всего лишь добавляет к её поведению аспект кеширования.
                </p>
            </div>
            <div class="text">
                <b>Применение «func.call» для передачи контекста</b>
                <p>
                    Упомянутый выше кеширующий декоратор не подходит для работы с методами объектов. <br><br>
                    В нашем случае мы можем использовать call в обёртке для передачи контекста в исходную функцию:
                </p>
                <img src="./img/16.png" alt="" width="100%">
            </div>
            <div class="text">
                <b>Переходим к нескольким аргументам с «func.apply»</b>
                <p>
                    Теперь давайте сделаем cachingDecorator ещё более универсальным. 
                    До сих пор он работал только с функциями с одним аргументом.<br><br>
                    Вот более мощный cachingDecorator:
                </p>
                <img src="./img/17.png" alt="" width="100%">
            </div>
            <div class="script">
                <b>Задачи</b>
                <p>
                    <code>
                        Задачи украли цыгане
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>6.10 Привязка контекста к функции</h3>
            <div class="text">
                <b>Потеря «this»</b>
                <p>
                    При передаче методов объекта в качестве колбэков, например для setTimeout, возникает потеря this. <br><br>
                    Вот как это может произойти в случае с setTimeout:
                </p>
                <img src="./img/18.png" alt="" width="100%">
                <p>
                    Это произошло потому, что setTimeout получил функцию sayHi отдельно от объекта user (именно здесь функция и потеряла контекст). <br><br>
                    То есть последняя строка может быть переписана как: let f = user.sayHi; setTimeout(f, 1000); // контекст user потеряли
                </p>
            </div>
            <div class="text">
                <b>Решение: привязать контекст с помощью bind</b>
                <p>
                    Базовый синтаксис bind: let boundFunc = func.bind(context);<br><br>
                    Вызов boundFunc подобен вызову func с фиксированным this. <br><br>
                    Теперь давайте попробуем с методом объекта:
                </p>
                <img src="./img/19.png" alt="" width="100%">
                <p>
                    Обычно bind применяется для фиксации this в методе объекта, чтобы передать его в качестве колбэка. Например, для setTimeout.
                </p>
            </div>
            <div class="script">
                <b>Задачи. Связанная функция как метод</b>
                <p>
                    <code>
                        null
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Повторный bind</b>
                <p>
                    <code>
                        Вася, т.к. мы не можем изменить уже созданную привязку.
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Свойство функции после bind</b>
                <p>
                    <code>
                        undefined, т.к. bind привязывается к другому объекту без свойства test.
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>6.11 Повторяем стрелочные функции</h3>
            <div class="text">
                <b>У стрелочных функций нет «this»</b>
                <p>
                    Если происходит обращение к this, его значение берётся снаружи. <br><br>
                    Стрелочные функции не могут быть использованы как конструкторы. Они не могут быть вызваны с new.
                </p>
            </div>
            <div class="text">
                <b>Стрелочные функции не имеют «arguments»</b>
                <p>
                    У стрелочных функций также нет переменной arguments.
                </p>
            </div>
        </section>
    </div>
</body>
</html>