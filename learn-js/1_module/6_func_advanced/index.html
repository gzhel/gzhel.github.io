<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css">
    <link rel="stylesheet" href="../../styles.css">
    <title>Продвинутая работа с функциями</title>
</head>
<body>
    <div class="learn-page__layout">
        <h1><a href="../../1_module/">Back to module 1</a></h1>
        <section class="learn-page__layout--study-block">
            <h3>Обозначения:</h3>
            <div class="text checked">Зеленый блок = прогресс изучения; Зеленая рамка = повторил, классно.</div>
            <div class="help helpful">Синий блок = полезная подсказка; Синяя рамка = очень важно, очень классно.</div>
            <div class="script useless">Красный блок = задача; Красная рамка = на мой взгляд не стоит внимания.</div>
        </section>
        <section class="learn-page__layout--study-block helpful">
            <h3>6.1 Рекурсия и стек</h3>
            <div class="text">
                <b>Два способа мышления</b>
                <p>
                    Рекурсия – это когда функция вызывает сама себя. <br><br>
                    Пример рекурсивной функции: function pow(x, n) {if (n == 1) {return x;} else {return x * pow(x, n - 1);}}<br></br>
                    В примере выше можно заметить if else, тут if служит моментом выхода из рекурсии, когда значение получено. <br><br>
                    Рекурсивное решение задачи обычно короче, чем итеративное. Можно писать рекурсию через стрелочные функции. <br><br>
                    Рекурсивные функции могут быть использованы для элегантного решения определённых задач.
                </p>
            </div>
            <div class="text">
                <b>Контекст выполнения, стек</b>
                <p>
                    Информация о процессе выполнения запущенной функции хранится в её контексте выполнения. <br><br>
                    Грубо говоря, контекст - это данные в некоторый момент исполнения функции. <br><br>
                    Когда функция производит вложенный вызов, происходит следующее:<br></br>
                    1) Выполнение текущей функции приостанавливается. <br><br>
                    2) Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения. <br><br>
                    3) Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения. <br><br>
                    4) После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена. <br><br><br>
                    Для функции function pow(x, n) {if (n == 1) {return x;} else {return x * pow(x, n - 1);}} контекст pow(2, 3) можно описать так: <br><br>
                    { x: 2, n: 3, строка 5 } -> { x: 2, n: 2, строка 1 } -> { x: 2, n: 1, строка 1 } -> функция завершается, возвращает 2. <br><br>
                    Далее функция закончилась, контекст { x: 2, n: 1, строка 1 } удаляется, на верхушке стека { x: 2, n: 2, строка 1 } возвращает 4,
                    после оно тоже удаляется, на верхушке { x: 2, n: 3, строка 5 } возвращает 8. Глубина рекурсии 3 (стоит помнить что это стек).<br></br>
                    Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.
                </p>
            </div>
            <div class="text">
                <b>Рекурсивные обходы</b>
                <p>
                    Например, у нас есть компания, в компании есть отделы, а там подотделы, а там подразделения, 
                    и в этой вложенности у сотрудников есть зп. Как её посчитать? Рекурсивно, итеративно не выйдет.
                </p>
                <img src="./img/1.png" alt="" width="100%">
            </div>
            <div class="text">
                <b>Связанный список</b>
                <p>
                    Для чего? Например упорядоченный список объектов (массив не подходит из-за медленной вставки/удаления). <br><br>
                    Элемент связанного списка определяется рекурсивно как объект с: value, next – свойство, 
                    ссылающееся на следующий элемент связанного списка или null, если это последний элемент. <br></br>
                    Пример: let list = { value: 1 }; list.next = { value: 2 }; list.next.next = { value: 3 }; list.next.next.next = { value: 4 }; <br><br>
                    1) Список можно легко разделить на несколько частей: let secondList = list.next.next; list.next.next = null; <br><br>
                    2) И впоследствии объединить обратно: list.next.next = secondList; <br><br>
                    3) Для добавления нового элемента, нужно обновить первый элемент списка: list = { value: "new item", next: list }; <br><br>
                    4) Чтобы удалить элемент из середины списка, нужно изменить значение next предыдущего элемента: list.next = list.next.next; <br><br>
                    Главным недостатком является то, что мы не можем легко получить доступ к элементу по его индексу. 
                    В простом массиве: arr[n] является прямой ссылкой. Но в списке мы должны начать с первого элемента и перейти в next N раз, чтобы получить N-й элемент.
                </p>
            </div>
            <div class="script">
                <b>Задачи. Вычислить сумму чисел до данного</b>
                <p>
                    <code>
                        function sumTo(n) {
                            let sum = 0;
                            for (let i = 1; i &lt;= n; i++) {
                                sum += i;
                            }
                            return sum;
                        }
                    </code>
                </p>
                <p>
                    <code>
                        function sumTo(n) {
                            if (n === 1) {
                                return 1;
                            }
                            return n + sumTo(n - 1);
                        }
                    </code>
                </p>
                <p>
                    <code>
                        // sumTo(n) = n*(n+1)/2 <br><br>
                        function sumTo(n) {
                            return n * (n + 1) / 2;
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Вычислить факториал</b>
                <p>
                    <code>
                        function factorial(n) {
                            return (n !== 1) ? factorial(n - 1) : 1;
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Числа Фибоначчи</b>
                <p>
                    <code>
                        function fib(n) {
                            return (n &lt;= 1) ? n : (fib(n - 1) + fib(n + 1));
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Вывод односвязного списка</b>
                <p>
                    <code>
                        function printList(list) {
                            while(list) {
                                alert(list.value);
                                list = list.next;
                            }
                        }
                    </code>
                </p>
                <p>
                    <code>
                        function printList(list) {
                            alert(list.value);
                            if (list.next) {
                                printList(list.next);
                            }
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Вывод односвязного списка</b>
                <p>
                    <code>
                        ???
                    </code>
                </p>
                <p>
                    <code>
                        function printReverseList(list) {
                            if (list.next) {
                                printReverseList(list.next);
                            }
                            alert(list.value);
                        }
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>6.2 Остаточные параметры и оператор расширения</h3>
            <div class="text">
                <b>Остаточные параметры (...)</b>
                <p>
                    Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена.<br><br>
                    Лишние аргументы не вызовут ошибку, но посчитаются только те, которые являются параметрами функции.<br></br>
                    Остаточные параметры означают: «собери оставшиеся параметры и положи их в массив»: function sumAll(...args) {...}<br><br>
                    Важно помнить, что остаточные парамтеры запишутся в массив args. <br><br>
                    Остаточные параметры должны располагаться в конце.
                </p>
            </div>
            <div class="text">
                <b>Переменная "arguments"</b>
                <p>
                    Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.<br><br>
                    Раньше не было остаточных параметров, и получить все аргументы функции можно было только с помощью arguments. <br><br>
                    Для более удобной работы с аргументами лучше использовать остаточные параметры. <br><br>
                    Стрелочные функции не имеют "arguments". Если мы обратимся к arguments из стрелочной функции, то получим аргументы внешней «нормальной» функции.
                </p>
            </div>
            <div class="text">
                <b>Оператор расширения</b>
                <p>
                    Он похож на остаточные параметры – тоже использует ..., но делает совершенно противоположное.<br><br>
                    Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов. <br><br>
                    Пример: let arr1 = [1, -2, 3, 4]; let arr2 = [8, 3, -8, 1]; alert( Math.max(...arr1, ...arr2) ); // 8 <br><br>
                    Оператор расширения можно использовать для слияния массивов: let arr = [3, 5, 1]; let arr2 = [8, 9, 15]; let merged = [0, ...arr, 2, ...arr2]; <br><br>
                    Оператор расширения работает только с итерируемыми объектами. Если нужно сделать из чего угодно массив, то Array.from — более универсальный метод.
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block helpful">
            <h3>6.3 Замыкание</h3>
            <div class="text">
                <b>Лексическое Окружение</b>
                <p>
                    В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, 
                    называемый лексическим окружением LexicalEnvironment, который состоит из двух частей: <br><br>
                    1) Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this). <br><br>
                    2) Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок). <br><br><br>
                    "Переменная" – это просто свойство специального внутреннего объекта: Environment Record. 
                    «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта». <br><br>
                    Переменная – это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом. <br><br>
                    Работа с переменными – это на самом деле работа со свойствами этого объекта.
                </p>
            </div>
            <div class="help">
                <b>Function Declaration</b>
                <p>
                    В отличие от переменных, объявленных с помощью let, они полностью инициализируются не тогда, 
                    когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение. <br><br>
                    Для верхнеуровневых функций это означает момент, когда скрипт начинает выполнение 
                    (Вот почему мы можем вызвать функцию, объявленную через Function Declaration, до того, как она определена):
                </p>
                <img src="./img/2.png" alt="" width="100%">
            </div>
            <div class="text">
                <b>Внутреннее и внешнее лексическое окружение</b>
                <p>
                    При запуске функции для неё автоматически создаётся новое лексическое окружение, для хранения локальных переменных и параметров вызова. <br><br>
                    В процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции) и внешнее (глобальное). <br><br>
                    Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, 
                    затем в следующем и так далее, до глобального. Если переменная не была найдена, это будет ошибкой в strict mode. Без strict mode, 
                    для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем. <br><br>
                    Функция получает текущее значение внешних переменных, то есть, их последнее значение: <br><br>
                    Старые значения переменных нигде не сохраняются. Когда функция хочет получить доступ к переменной, 
                    она берёт её текущее значение из своего или внешнего лексического окружения.
                </p>
                <img src="./img/3.png" alt="" width="100%">
            </div>
            <div class="help">
                <b>Один вызов – одно лексическое окружение</b>
                <p>
                    Новое лексическое окружение функции создаётся каждый раз, когда функция выполняется. <br><br>
                    Если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, 
                    со своими, специфичными для этого вызова, локальными переменными и параметрами.
                </p>
            </div>
            <div class="text">
                <b>Вложенные функции</b>
                <p>
                    Функция называется «вложенной», когда она создаётся внутри другой функции. <br><br>
                    В JavaScript вложенные функции используются очень часто. <br><br>
                    Пример вложенной функции:
                </p>
                <img src="./img/4.png" alt="" width="100%">
                <p>
                    Когда внутренняя функция начинает выполняться, начинается поиск переменной count++ изнутри-наружу: <br><br>
                    Локальные переменные вложенной функции… Переменные внешней функции… И так далее, пока не будут достигнуты глобальные переменные. <br><br>
                    1) Сбросить счётчик внутри функции мы не можем. Мы не можем получить к ней доступ извне. <br><br>
                    2) Для каждого вызова функции создаётся новое лекс. окружение: let fn1 = funcName(); let fn2 = funcName(); - независимы друг от друга.
                </p>
            </div>
            <div class="text">
                <b>Окружение в деталях</b>
                <p>
                    1) Когда скрипт только начинает выполняться, есть только глобальное лексическое окружение <br><br>
                    Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были созданы.
                </p>
                <img src="./img/5.png" alt="" width="100%">
                <p>
                    2) Код продолжает выполняться, объявляется новая глобальная переменная counter, которой присваивается результат вызова makeCounter.
                    В момент вызова makeCounter() создаётся лексическое окружение, для хранения его переменных и аргументов.
                </p>
                <img src="./img/6.png" alt="" width="100%">
                <p>
                    3) В процессе выполнения makeCounter() создаётся небольшая вложенная функция. Не имеет значения, какой способ объявления функции используется: 
                    Function Declaration или Function Expression. Все функции получают свойство [[Environment]], которое ссылается на лексическое окружение, 
                    в котором они были созданы. <br><br>
                    На этом шаге внутренняя функция была создана, но ещё не вызвана. Код внутри function() { return count++ } не выполняется.
                </p>
                <img src="./img/7.png" alt="" width="100%">
                <p>
                    4) Выполнение продолжается, вызов makeCounter() завершается, и результат (небольшая вложенная функция) присваивается глобальной переменной counter. <br><br>
                    В этой функции есть только одна строчка: return count++, которая будет выполнена, когда мы вызовем функцию.
                </p>
                <img src="./img/8.png" alt="" width="100%">
                <p>
                    5) При вызове counter() для этого вызова создаётся новое лексическое окружение. Оно пустое, так как в самом counter локальных переменных нет. 
                    Но [[Environment]] counter используется, как ссылка на внешнее лексическое окружение outer, 
                    которое даёт доступ к переменным предшествующего вызова makeCounter, где counter был создан. <br><br>
                    Теперь, когда вызов ищет переменную count, он сначала ищет в собственном лексическом окружении (пустое), 
                    а затем в лексическом окружении предшествующего вызова makeCounter(), где и находит её. <br><br>
                    В большинстве случаев, объект лексического окружения существует до того момента, пока есть функция, которая может его использовать. 
                </p>
                <img src="./img/9.png" alt="" width="100%">
                <p>
                    6) Вызов counter() не только возвращает значение count, но также увеличивает его. Обратите внимание, 
                    что модификация происходит «на месте». Значение count изменяется конкретно в том окружении, где оно было найдено. <br><br>
                    Следующие вызовы counter() сделают то же самое.
                </p>
                <img src="./img/10.png" alt="" width="100%">
                <p>
                    Ответ на второй вопрос из начала главы: <br><br>
                    Функция work() в коде ниже получает name из того места, где была создана, через ссылку на внешнее лексическое окружение: <br><br>
                    Так что, результатом будет "Pete". Но, если бы в makeWorker() не было let name, тогда бы поиск продолжился дальше и была бы взята глобальная переменная.
                </p>
                <img src="./img/11.png" alt="" width="100%">
            </div>
            <div class="help">
                <b>Замыкания</b>
                <p>
                    Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. <br><br>
                    То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] 
                    и все они могут получить доступ к внешним переменным.
                </p>
            </div>
            <div class="text">
                <b>Блоки кода и циклы</b>
                <p>
                    Предыдущие примеры сосредоточены на функциях. Но лексическое окружение существует для любых блоков кода {...}. <br><br>
                    Лексическое окружение создаётся при выполнении блока кода и содержит локальные переменные для этого блока. <br><br>
                    1) If: В следующем примере переменная user существует только в блоке if (а phrase берётся из ссылки на внешнее окружение):
                </p>
                <img src="./img/12.png" alt="" width="100%">
                <p>
                    2) For, while: Для цикла у каждой итерации своё отдельное лексическое окружение. Если переменная объявлена в for(let ...), то она также в нём. <br><br>
                    for (let i = 0; i &lt; 10; i++) {...} alert(i); // Ошибка, нет такой переменной <br><br>
                    let i визуально находится снаружи {...}. Но конструкция for – особенная в этом смысле, 
                    у каждой итерации цикла своё собственное лексическое окружение с текущим i в нём. <br><br>
                    3) Блоки кода: Мы также можем использовать «простые» блоки кода {...}, чтобы изолировать переменные в «локальной области видимости»: <br><br>
                    {let message = "Hello"; alert(message); // Hello} alert(message); // Ошибка: переменная message не определена
                </p>
            </div>
            <div class="help">
                <b>IIFE</b>
                <p>
                    «immediately-invoked function expressions» (аббревиатура IIFE), что означает функцию, запускаемую сразу после объявления. <br><br>
                    Это не то, что мы должны использовать сегодня, но, полезно понимать принцип работы. <br><br>
                    Синтаксис: (function() {let message = "Hello";alert(message);})(); <br><br>
                    Стоит обратить внимание, что это работает только с анонимными функциями.
                </p>
            </div>
            <div class="script">
                <b>Задачи. Независимы ли счётчики?</b>
                <p>
                    <code>
                        Независимы. Покажет 0, 1.
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Объект счётчика</b>
                <p>
                    <code>
                        // Одно лексическое окружение, имеют доступ к count <br><br>
                        counter.up() // 1 <br><br>
                        counter.up() // 2 <br><br>
                        counter.down() // 1
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Функция в if</b>
                <p>
                    <code>
                        // ошибка, т.к. sayHi объявлена внутри if, существует только внутри этого блока {}
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Сумма с помощью замыканий</b>
                <p>
                    <code>
                        function sum(a) {
                            return function(b) {
                                return a + b;
                            }
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Фильтрация с помощью функции</b>
                <p>
                    <code>
                        function inBetween(a, b) {
                            return function(x) {
                                return (x >= a && x &lt;= b); 
                            }
                        }
                        // filter вызывается много раз для каждого элемента массива, где х - это каждый элемент массива
                    </code>
                </p>
                <p>
                    <code>
                        function inArray(arr) {
                            return function(x) {
                                return arr.includes(x);
                            }
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Сортировать по полю</b>
                <p>
                    <code>
                        function byField(fieldName) {
                            return function(a, b) {
                                return (a[fieldName] > b[fieldName]) ? 1 : -1;
                            }
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Армия функций</b>
                <p>
                    <code>
                        ???
                    </code>
                </p>
            </div>
        </section>
    </div>
</body>
</html>