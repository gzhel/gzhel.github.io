<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css">
    <link rel="stylesheet" href="../../styles.css">
    <title>Основы JavaScript</title>
</head>
<body>
    <div class="learn-page__layout">
        <h1><a href="../../1_module/">Back to module 1</a></h1>
        <section class="learn-page__layout--study-block">
            <h3>Обозначения:</h3>
            <div class="text checked">Зеленый блок = прогресс изучения; Зеленая рамка = повторил, классно.</div>
            <div class="help helpful">Синий блок = полезная подсказка; Синяя рамка = очень важно, очень классно.</div>
            <div class="script useless">Красный блок = задача; Красная рамка = на мой взгляд не стоит внимания.</div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>4.1 Объекты</h3>
            <div class="text">
                <b>Основы</b>
                <p>
                    Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств. 
                    Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно. <br><br>
                    Обычно используют вариант с фигурными скобками {...}. Такое объявление называют литералом объекта или литеральной нотацией.
                </p>
            </div>
            <div class="text">
                <b>Литералы и свойства</b>
                <p>
                    Синтаксис литерала: let user = { name: "John", age: 30 }; <br><br>
                    У каждого свойства есть ключ (также называемый «имя» или «идентификатор»). 
                    После имени свойства следует двоеточие ":", и затем указывается значение свойства. Если в объекте несколько свойств, то они перечисляются через запятую. <br><br>
                    1) Для обращения к свойствам используется запись «через точку»: user.name ; <br><br>
                    2) Для удаления свойства мы можем использовать оператор delete: delete user.age; <br><br>
                    3) Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки. <br><br>
                    4) Последнее свойство объекта может заканчиваться запятой.
                </p>
            </div>
            <div class="help">
                <b>Объект, объявленный как константа, может быть изменён</b>
                <p>
                    const user = {name: "John"}; <br><br>
                    user.name = "Pete"; <br><br>
                    Тут аналогично массивам, чтобы такого не было, используют freeze().
                </p>
            </div>
            <div class="text">
                <b>Квадратные скобки</b>
                <p>
                    Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает: user.likes birds = true; (ошибка) <br><br>
                    В таких случаях происходит обрещение через квадратные скобки: user["likes birds"] = true; <br><br>
                    Важный момент. В квадратные скобки можно добавить переменную, которая зависит от чего-то ещё: let key = "likes birds"; user[key] = true;
                </p>
            </div>
            <div class="text">
                <b>Вычисляемые свойства</b>
                <p>
                    Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства: <br><br>
                    let fruit = prompt("Какой фрукт купить?", "apple"); let bag = {[fruit]: 5,};<br><br>
                    В большинстве случаев, когда имена свойств известны и просты, используется запись через точку. Если же нам нужно что-то более сложное, то мы используем квадратные скобки.
                </p>
            </div>
            <div class="text">
                <b>Свойство из переменной</b>
                <p>
                    Тут речь о сокращениях ES6+: <br><br>
                    Внутри объекта вместо: {name: name, age: age,} можно использовать {name, age,}
                </p>
            </div>
            <div class="text">
                <b>Ограничения на имена свойств</b>
                <p>
                    Как мы уже знаем, имя переменной не может совпадать с зарезервированными словами, такими как «for», «let», «return» и т.д. 
                    Но для свойств объекта такого ограничения нет (но лучше не экспериментировать с этим). 
                </p>
            </div>
            <div class="text">
                <b>Проверка существования свойства, оператор «in»</b>
                <p>
                    Существует специальный оператор "in" для проверки существования свойства в объекте (есть ли св-во А в объекте Б). <br><br>
                    Синтаксис: "key" in object. <br><br>
                    При обращении к свойству, которого нет, возвращается undefined. Это позволяет просто проверить существование свойства. 
                    Поэтому оператор in является экзотическим гостем в коде (нужен когда свойство существует, но содержит значение undefined).
                </p>
            </div>
            <div class="text">
                <b>Цикл «for…in»</b>
                <p>
                    Для перебора всех свойств объекта используется цикл for..in. <br><br>
                    Синтаксис: for (key in object) {...} <br><br>
                    Можно вывести ключи (key) или значения ключей (object[key]).
                </p>
            </div>
            <div class="text">
                <b>Упорядочение свойств объекта</b>
                <p>
                    Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания. <br><br>
                    Для чего нужны целочисленные ключи? Например, для объекта с телефонной книгой номеров. <br><br>
                    Чтобы решить нашу проблему (ключи-числа сортируются по возврастанию) нужно добавить знак "+" перед каждым 
                    кодом ("+0" вместо "0", когда обратимся это всё равно будет 0, но с преобразованный через +value).
                </p>
            </div>
            <div class="script">
                <b>Задачи. Привет, object</b>
                <p>
                    <code>
                        const user = {};
                        user.name = "John";
                        user.surname = "Smith";
                        user.name = "Pete";
                        delete user.name;
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Проверка на пустоту</b>
                <p>
                    <code>
                        const isEmpty = obj => {
                            for (let key in obj) {
                                return false;
                            }
                            return true;
                        };
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Объекты-константы?</b>
                <p>
                    <code>
                        Да. Мы можем переопределить то, что "внутри", но сам объект не можем.
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Сумма свойств объекта</b>
                <p>
                    <code>
                        let sum = 0;
                        for (let key in salaries) {
                            sum += salaries[key];
                        }
                    </code>
                </p>
            </div>
            <div class="script">
                <b>Задачи. Умножаем все числовые свойства на 2</b>
                <p>
                    <code>
                        const multiplyNumeric = obj => {
                            for (let key in obj) {
                                if ((typeof obj[key]) === "number") {
                                    obj[key] *= 2;
                                }
                            }
                        };
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>4.2 Копирование объектов и ссылки</h3>
            <div class="text">
                <b>Основы</b>
                <p>
                    Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке». <br><br>
                    Пример со строкой: let message = "Привет!"; let phrase = message; В итоге имеем <b>две независимые переменные</b>, каждая из которых хранит строку "Привет!".  <br><br>
                    Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется. <br><br>
                    Пример с объектом: let user = { name: "Иван" }; let admin = user; // копируется ссылка, изменим admin, изменится user.
                </p>
            </div>
            <div class="text">
                <b>Сравнение по ссылке</b>
                <p>
                    Два объекта равны только в том случае, если это один и тот же объект. <br><br>
                    Если две переменные ссылаются на один объект, они равны. Если две переменные имеют одну и ту же структуру объекта, они не равны.
                </p>
            </div>
            <div class="text">
                <b>Клонирование и объединение объектов, Object.assign</b>
                <p>
                    Как создать независимую копию, клон объекта?<br><br>
                    Можем использовать метод Object.assign: Object.assign(dest, [src1, src2, src3...]). <br><br>
                    dest — целевой объект. src1, ..., srcN - исходные объекты. Возвращает объект dest.
                </p>
            </div>
            <div class="text">
                <b>Вложенное клонирование</b>
                <p>
                    Значением ключа объекта может быть другой объект. Как клонировать?<br><br>
                    В цикле клонирования делать проверку, не является ли значение user[key] объектом, и если это так – скопировать и его структуру тоже. <br><br>
                    Для этого существует метод _.cloneDeep(obj) из JavaScript-библиотеки lodash. 
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>4.3 Сборка мусора</h3>
            <div class="help">
                <b>Основы</b>
                <p>
                    1) Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её. <br><br>
                    2) Объекты сохраняются в памяти, пока они достижимы. <br><br>
                    3) Наличие ссылки не гарантирует, что объект достижим (от корня): несколько взаимосвязанных объектов могут стать недостижимыми как единое целое.
                </p>
            </div>
        </section>
    </div>
</body>
</html>