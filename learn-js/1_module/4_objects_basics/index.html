<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css">
    <link rel="stylesheet" href="../../styles.css">
    <title>Объекты: основы</title>
</head>
<body>
    <div class="learn-page__layout">
        <h1><a href="../../1_module/">Back to module 1</a></h1>
        <section class="learn-page__layout--study-block">
            <h3>Обозначения:</h3>
            <div class="text checked">Зеленый блок = прогресс изучения; Зеленая рамка = повторил, классно.</div>
            <div class="help helpful">Синий блок = полезная подсказка; Синяя рамка = очень важно, очень классно.</div>
            <div class="script useless">Красный блок = задача; Красная рамка = на мой взгляд не стоит внимания.</div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>4.1 Объекты</h3>
            <div class="text checked">
                <b>Основы</b>
                <p>
                    Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств. 
                    Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно. <br><br>
                    Обычно используют вариант с фигурными скобками {...}. Такое объявление называют литералом объекта или литеральной нотацией.
                </p>
            </div>
            <div class="text helpful">
                <b>Литералы и свойства</b>
                <p>
                    Синтаксис литерала: let user = { name: "John", age: 30 }; <br><br>
                    У каждого свойства есть ключ (также называемый «имя» или «идентификатор»). 
                    После имени свойства следует двоеточие ":", и затем указывается значение свойства. Если в объекте несколько свойств, то они перечисляются через запятую. <br><br>
                    1) Для обращения к свойствам используется запись «через точку»: user.name ; <br><br>
                    2) Для удаления свойства мы можем использовать оператор delete: delete user.age; <br><br>
                    3) Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки. <br><br>
                    4) Последнее свойство объекта может заканчиваться запятой.
                </p>
            </div>
            <div class="help checked">
                <b>Объект, объявленный как константа, может быть изменён</b>
                <p>
                    const user = {name: "John"}; <br><br>
                    user.name = "Pete"; <br><br>
                    Тут аналогично массивам, чтобы такого не было, используют freeze().
                </p>
            </div>
            <div class="text helpful">
                <b>Квадратные скобки</b>
                <p>
                    Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает: user.likes birds = true; (ошибка) <br><br>
                    В таких случаях происходит обрещение через квадратные скобки: user["likes birds"] = true; <br><br>
                    Важный момент. В квадратные скобки можно добавить переменную, которая зависит от чего-то ещё: let key = "likes birds"; user[key] = true;
                </p>
            </div>
            <div class="text checked">
                <b>Вычисляемые свойства</b>
                <p>
                    Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства: <br><br>
                    let fruit = prompt("Какой фрукт купить?", "apple"); let bag = {[fruit]: 5,};<br><br>
                    В большинстве случаев, когда имена свойств известны и просты, используется запись через точку. Если же нам нужно что-то более сложное, то мы используем квадратные скобки.
                </p>
            </div>
            <div class="text checked">
                <b>Свойство из переменной</b>
                <p>
                    Тут речь о сокращениях ES6+: <br><br>
                    Внутри объекта вместо: {name: name, age: age,} можно использовать {name, age,}
                </p>
            </div>
            <div class="text useless">
                <b>Ограничения на имена свойств</b>
                <p>
                    Как мы уже знаем, имя переменной не может совпадать с зарезервированными словами, такими как «for», «let», «return» и т.д. 
                    Но для свойств объекта такого ограничения нет (но лучше не экспериментировать с этим). 
                </p>
            </div>
            <div class="text checked">
                <b>Проверка существования свойства, оператор «in»</b>
                <p>
                    Существует специальный оператор "in" для проверки существования свойства в объекте (есть ли св-во А в объекте Б). <br><br>
                    Синтаксис: "key" in object. <br><br>
                    При обращении к свойству, которого нет, возвращается undefined. Это позволяет просто проверить существование свойства. 
                    Поэтому оператор in является экзотическим гостем в коде (нужен когда свойство существует, но содержит значение undefined).
                </p>
            </div>
            <div class="text useless">
                <b>Цикл «for…in»</b>
                <p>
                    Для перебора всех свойств объекта используется цикл for..in. <br><br>
                    Синтаксис: for (key in object) {...} <br><br>
                    Можно вывести ключи (key) или значения ключей (object[key]).
                </p>
            </div>
            <div class="text useless">
                <b>Упорядочение свойств объекта</b>
                <p>
                    Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания. <br><br>
                    Для чего нужны целочисленные ключи? Например, для объекта с телефонной книгой номеров. <br><br>
                    Чтобы решить нашу проблему (ключи-числа сортируются по возврастанию) нужно добавить знак "+" перед каждым 
                    кодом ("+0" вместо "0", когда обратимся это всё равно будет 0, но с преобразованный через +value).
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Привет, object</b>
                <p>
                    <code>
                        const user = {};
                        user.name = "John";
                        user.surname = "Smith";
                        user.name = "Pete";
                        delete user.name;
                    </code>
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Проверка на пустоту</b>
                <p>
                    <code>
                        const isEmpty = obj => {
                            for (let key in obj) {
                                return false;
                            }
                            return true;
                        };
                    </code>
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Объекты-константы?</b>
                <p>
                    <code>
                        Да. Мы можем переопределить то, что "внутри", но сам объект не можем.
                    </code>
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Сумма свойств объекта</b>
                <p>
                    <code>
                        let sum = 0;
                        for (let key in salaries) {
                            sum += salaries[key];
                        }
                    </code>
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Умножаем все числовые свойства на 2</b>
                <p>
                    <code>
                        const multiplyNumeric = obj => {
                            for (let key in obj) {
                                if ((typeof obj[key]) === "number") {
                                    obj[key] *= 2;
                                }
                            }
                        };
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>4.2 Копирование объектов и ссылки</h3>
            <div class="text helpful">
                <b>Основы</b>
                <p>
                    Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке». <br><br>
                    Пример со строкой: let message = "Привет!"; let phrase = message; В итоге имеем <b>две независимые переменные</b>, каждая из которых хранит строку "Привет!".  <br><br>
                    Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется. <br><br>
                    Пример с объектом: let user = { name: "Иван" }; let admin = user; // копируется ссылка, изменим admin, изменится user.
                </p>
            </div>
            <div class="text checked">
                <b>Сравнение по ссылке</b>
                <p>
                    Два объекта равны только в том случае, если это один и тот же объект. <br><br>
                    Если две переменные ссылаются на один объект, они равны. Если две переменные имеют одну и ту же структуру объекта, они не равны.
                </p>
            </div>
            <div class="text helpful">
                <b>Клонирование и объединение объектов, Object.assign</b>
                <p>
                    Как создать независимую копию, клон объекта?<br><br>
                    Можем использовать метод Object.assign: Object.assign(dest, [src1, src2, src3...]). <br><br>
                    dest — целевой объект. src1, ..., srcN - исходные объекты. Возвращает объект dest.
                </p>
            </div>
            <div class="text checked">
                <b>Вложенное клонирование</b>
                <p>
                    Значением ключа объекта может быть другой объект. Как клонировать?<br><br>
                    В цикле клонирования делать проверку, не является ли значение user[key] объектом, и если это так – скопировать и его структуру тоже. <br><br>
                    Для этого существует метод _.cloneDeep(obj) из JavaScript-библиотеки lodash. 
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>4.3 Сборка мусора</h3>
            <div class="help useless">
                <b>Основы</b>
                <p>
                    1) Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её. <br><br>
                    2) Объекты сохраняются в памяти, пока они достижимы. <br><br>
                    3) Наличие ссылки не гарантирует, что объект достижим (от корня): несколько взаимосвязанных объектов могут стать недостижимыми как единое целое.
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block helpful">
            <h3>4.4 Методы объекта, "this"</h3>
            <div class="text checked">
                <b>Примеры методов</b>
                <p>
                    Объект может хранить в значениях любые данные, в том числе и методы. Пример: let user = {sayHi: () => alert("Hi!")}; <br><br>
                    Можно задать метод объекта: сразу в объекте; через создание поля через точку (user.sayHi = ...); через ссылку на существующую функцию. <br><br>
                    Синтаксис: let user = {sayHi: () => alert("Hi!")}; или let user = {sayHi() => {alert("Hi!")}}; второй вариант используется чаще. 
                </p>
            </div>
            <div class="text helpful">
                <b>Ключевое слово «this» в методах</b>
                <p>
                    Для доступа к информации <b>внутри объекта</b> метод может использовать ключевое слово this. <br><br>
                    Значение this – это объект «перед точкой», который использовался для вызова метода (user. тут user это this для того что после точки). <br><br>
                    Можно вместо this.key использовать obj.key, но так лучше не делать т.к. будут ошибки при создании копий (ссылок на объект).
                </p>
                <img src="./img/1.png" alt="" width="100%">
            </div>
            <div class="text checked">
                <b>«this» не является фиксированным</b>
                <p>
                    Значение this вычисляется во время выполнения кода и зависит от контекста. 
                    Т.е. привяжем одну функцию к двум объектам, спросим у этой функции this.name, получим разные this. <br><br>
                    Правило простое: при вызове obj.f() значение this внутри f равно obj.
                </p>
            </div>
            <div class="help checked">
                <b>Вызов без объекта: this == undefined</b>
                <p>
                    Можем вызвать функцию без использования объекта: function sayHi() {alert(this;)} <br><br>
                    В строгом режиме ("use strict") в таком коде значением this будет являться undefined. 
                    Если мы попытаемся получить доступ к name, используя this.name – это вызовет ошибку.
                </p>
            </div>
            <div class="help checked">
                <b>Последствия свободного this</b>
                <p>
                    В JavaScript this является «свободным», его значение вычисляется в момент вызова 
                    метода и не зависит от того, где этот метод был объявлен, а зависит от того, какой 
                    объект вызывает метод (какой объект стоит «перед точкой»).
                </p>
            </div>
            <div class="text helpful">
                <b>У стрелочных функций нет «this»</b>
                <p>
                    Если мы используем this внутри стрелочной функции, то его значение <b>берётся из внешней «нормальной» функции</b>. <br><br>
                    Пример: let user = {firstName: "Илья", sayHi() {let arrow = () => alert(this.firstName); arrow();}}; user.sayHi(); // Илья <br><br>
                    Если обратимся в стрелочной функции к полю через this, получим undefined (или пустую строку если обращаемся к строке).
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Проверка синтаксиса</b>
                <p>
                    <code>
                        Ответ: "Джон" // неправильно, оказалось ошибка, т.к. после объекта нет точки с запятой
                    </code>
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Объясните значение "this"</b>
                <p>
                    <code>
                        1. Вызов метода объекта через точку, this ссылается на объект [object Object] <br><br>
                        2. То же самое, obj.go ссылается на obj.go, а потом вызываем его. <br><br>
                        3. Сначала переменная method сослалась на метод obj.go, но тут потерялся контекст, произошёл вызов и получили undefined. <br><br>
                        4. ??? // Прочитал, оказывается при сравнении через логические операторы ReferenceType (ссылочный тип) теряется.
                    </code>
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Использование "this" в литерале объекта</b>
                <p>
                    <code>
                        Ошибка: makeUser() вызывается не через точку и this существует только внутри функции, а там ничего нет, и он равен undefined.
                    </code>
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Создайте калькулятор</b>
                <p>
                    <code>
                        const calculator = {
                            read() {
                                this.a = +prompt("A:", 0);
                                this.b = +prompt("B:", 0);
                            },
                            sum() {
                                return this.a + this.b;
                            },
                            mul() {
                                return this.a * this.b;
                            }
                        };
                    </code>
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Цепь вызовов</b>
                <p>
                    <code>
                        let ladder = {
                            step: 0,
                            up() {
                                this.step++;
                                return this;
                            },
                            down() {
                                this.step--;
                                return this;
                            },
                            showStep: function() {
                                alert( this.step );
                                return this;
                            }
                        };
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>4.5 Конструкторы, создание объектов через "new"</h3>
            <div class="text helpful">
                <b>Функция-конструктор</b>
                <p>
                    1) Имя функции-конструктора должно начинаться с большой буквы. <br><br>
                    2) Функция-конструктор должна вызываться при помощи оператора "new". <br><br>
                    Синтаксис: function User(name) {this.name = name;} let user = new User("Вася"); <br><br>
                    Как это работает:
                </p>
                <img src="./img/2.png" alt="" width="100%">
            </div>
            <div class="help useless">
                <b>Проверка на вызов в режиме конструктора: new.target</b>
                <p>
                    Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него.
                </p>
            </div>
            <div class="text useless">
                <b>Возврат значения из конструктора return</b>
                <p>
                    Обычно конструкторы ничего не возвращают явно. Их задача – записать все необходимое в this, который в итоге станет результатом. <br><br>
                    Если return всё же есть, то return возвращает объект вместо this: return { name: "Godzilla" }; <br><br>
                    Обычно у конструкторов отсутствует return. 
                </p>
            </div>
            <div class="text checked">
                <b>Создание методов в конструкторе</b>
                <p>
                    В this мы можем добавлять не только свойства, но и методы (аналогично объектам). <br><br>
                    Для создания сложных объектов есть классы.
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Две функции - один объект</b>
                <p>
                    <code>
                        Если возвращают один и тот же объект: <br><br>
                        let obj = {};
                        function A() {return obj;}
                        function B() {return obj;}
                        let a = new A(); // obj
                        let b = new B(); // obj
                        alert(a === b); // true
                    </code>
                </p>
            </div>
            <div class="script helpful">
                <b>Задачи. Создание калькулятора при помощи конструктора</b>
                <p>
                    <code>
                        function Calculator(a, b) {
                            this.read = function() {
                                this.a = +prompt("A:", 0);
                                this.b = +prompt("B:", 0);
                            };
                            this.sum = function() {
                                return this.a + this.b;
                            };
                            this.mul = function() {
                                return this.a * this.b;
                            };
                        }
                    </code>
                </p>
            </div>
            <div class="script checked">
                <b>Задачи. Создаём Accumulator</b>
                <p>
                    <code>
                        function Accumulator(startingValue) {
                            this.value = startingValue;
                            this.read = function() {
                                this.value = this.value + +prompt("Число:", 0);
                            };
                        }
                    </code>
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>4.6 Опциональная цепочка '?.'</h3>
            <div class="help checked">
                <b>Проблема «несуществующего свойства»</b>
                <p>
                    Опциональная цепочка ?. — это безопасный способ доступа к свойствам вложенных объектов, 
                    даже если какое-либо из промежуточных свойств не существует. <br><br>
                    Краткая история: до optional chaining была проблема, если какое-то поле объекта отсутствует или ещё не прогрузилось,
                    появлялась ошибка. Тогда это решалось через && типо user && user.name; 
                </p>
            </div>
            <div class="text helpful">
                <b>Проблема «несуществующего свойства»</b>
                <p>
                    Опциональная цепочка ?. останавливает вычисление и возвращает undefined, 
                    если часть перед ?. имеет значение undefined или null (ошибки нет, все довольны).<br><br>
                    Пример синтаксиса: user?.address?.street. <br><br>
                    Не злоупотребляйте опциональной цепочкой (используем только когда думаем, что значения может не быть). <br><br>
                    Переменная перед ?. должна быть объявлена. Если переменной user вообще не существует, то выражение user?.anything выдаст ошибку.
                    Объявление переменной (например let/const/var user) обязательно должно быть.
                </p>
            </div>
            <div class="help useless">
                <b>Сокращённое вычисление</b>
                <p>
                    ?. немедленно останавливает вычисление, если левой части не существует.<br><br>
                    Последующие вызовы функций или операции не будут выполнены.
                </p>
            </div>
            <div class="text helpful">
                <b>Другие варианты применения: ?.(), ?.[]</b>
                <p>
                    Работает с функциями и квадратными скобками.<br><br>
                    ?.() используется для вызова потенциально несуществующей функции: user1.admin?.(); <br><br>
                    ?.[], если значение свойства требуется получить с помощью квадратных скобок [], а не через точку (например когда ключ это переменная). <br><br>
                    ?. можно совместно использовать с delete: delete user?.name; // Удалить user.name, если пользователь существует <br><br>
                    ?. для безопасного чтения и удаления, но не для записи, записать что-то в объект через ?. не получится.
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>4.7 Тип данных Symbol</h3>
            <div class="text checked">
                <b>Символы</b>
                <p>
                    «Символ» представляет собой уникальный идентификатор. Синтаксис: let id = Symbol();<br><br>
                    При создании символу можно дать описание (также называемое имя): let id = Symbol("id"); <br><br>
                    Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, 
                    это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет. <br><br>
                </p>
            </div>
            <div class="text useless">
                <b>«Скрытые» свойства</b>
                <p>
                    Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно 
                    обратиться и перезаписать их из других частей программы. Пример: let id = Symbol("id"); user[id] = 1;<br><br>
                    Почему лучше использовать Symbol("id"), а не строку "id"? Если мы редактируем сторонний код, то
                    их идентификаторы и наши идентификаторы могут называться одинаково, но благодаря Symbol не будут равны.
                </p>
            </div>
            <div class="text useless">
                <b>Символы в литеральном объекте</b>
                <p>
                    Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки. <br><br>
                    Пример: [id]: 123 // просто "id: 123" не сработает
                </p>
            </div>
            <div class="text useless">
                <b>Символы игнорируются циклом for…in</b>
                <p>
                    Свойства, чьи ключи – символы, не перебираются циклом for..in.<br><br>
                    А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства.
                </p>
            </div>
            <div class="text useless">
                <b>Итоги</b>
                <p>
                    Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. 
                    Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. 
                    Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, 
                    Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.
                </p>
            </div>
        </section>
        <section class="learn-page__layout--study-block">
            <h3>4.8 Преобразование объектов в примитивы</h3>
            <div class="help useless">
                <b>Основы</b>
                <p>
                    1) Все объекты в логическом контексте являются true. Существуют лишь их численные и строковые преобразования.<br><br>
                    2) Численные преобразования происходят, когда мы вычитаем объекты или выполняем математические операции. Например, 
                    объекты Date (мы рассмотрим их в статье Дата и время) могут вычитаться, и результатом date1 - date2 будет временной отрезок между двумя датами.<br><br>
                    3) Что касается строковых преобразований – они обычно происходят, когда мы выводим объект alert(obj), а также в других случаях, когда объект используется как строка.
                </p>
            </div>
            <div class="text useless">
                <b>Преобразование к примитивам</b>
                <p>
                    Существуют три варианта преобразований: <br><br>
                    1) "string" (для alert и других операций, которым нужна строка).<br><br>
                    2) "number" (для математических операций).<br><br>
                    3) "default" (когда оператор «не уверен», какой тип ожидать).
                </p>
            </div>
            <div class="text useless">
                <b>Алгоритм преобразований к примитивам</b>
                <p>
                    1) Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует. <br><br>
                    2) Иначе, если хинт равен "string" происходит попытка вызвать obj.toString(), затем obj.valueOf(), смотря что есть. <br><br>
                    3) Иначе, если хинт равен "number" или "default" происходит попытка вызвать obj.valueOf(), затем obj.toString(), смотря что есть.
                </p>
                <img src="./img/3.png" alt="" width="100%">
            </div>
            <div class="text checked">
                <b>Итоги</b>
                <p>
                    На практике довольно часто достаточно реализовать только obj.toString() как «универсальный» метод для всех типов преобразований, 
                    возвращающий «читаемое» представление объекта, достаточное для логирования или отладки.
                </p>
            </div>
        </section>
    </div>
</body>
</html>